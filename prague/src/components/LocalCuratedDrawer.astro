---
type CuratedSlot = {
  blockId: string;
  blockType: string;
  target: 'block' | 'item' | 'item-public-id';
  itemIndex?: number;
  label: string;
  currentPublicId: string;
};

type CuratedBlock = {
  blockId: string;
  blockType: string;
  blockIndex?: number;
  label?: string;
  slots: CuratedSlot[];
};

type Props = {
  widget: string;
  page: string;
  blocks: CuratedBlock[];
};

type NormalizedSlot = CuratedSlot & { slotIndex: number };
type NormalizedBlock = {
  blockId: string;
  blockType: string;
  blockIndex: number;
  label: string;
  slots: NormalizedSlot[];
};

const { widget, page, blocks } = Astro.props;
const localHosts = new Set(['localhost', '127.0.0.1', '::1']);
const isLocalDev = import.meta.env.DEV && localHosts.has(Astro.url.hostname);

let runningSlotIndex = 0;
const normalizedBlocks: NormalizedBlock[] = [];

if (Array.isArray(blocks)) {
  blocks.forEach((block, arrayIndex) => {
    const blockId = String(block?.blockId || '').trim();
    const blockType = String(block?.blockType || '').trim();
    if (!blockId || !blockType) return;

    const blockIndex = Number.isInteger(block?.blockIndex) ? Number(block.blockIndex) : arrayIndex;
    const blockLabelRaw = String(block?.label || '').trim();
    const blockLabel = blockLabelRaw || `${blockType} block`;
    const normalizedSlots: NormalizedSlot[] = [];
    const rawSlots = Array.isArray(block?.slots) ? block.slots : [];

    rawSlots.forEach((slot) => {
      const label = String(slot?.label || '').trim();
      if (!label) return;
      normalizedSlots.push({
        blockId,
        blockType,
        target:
          slot?.target === 'item' || slot?.target === 'item-public-id'
            ? slot.target
            : 'block',
        itemIndex: typeof slot?.itemIndex === 'number' ? slot.itemIndex : undefined,
        label,
        currentPublicId: String(slot?.currentPublicId || '').trim(),
        slotIndex: runningSlotIndex++,
      });
    });

    normalizedBlocks.push({
      blockId,
      blockType,
      blockIndex,
      label: blockLabel,
      slots: normalizedSlots,
    });
  });
}

const normalizedSlotCount = normalizedBlocks.reduce((sum, block) => sum + block.slots.length, 0);
const drawerContext = JSON.stringify({
  widget,
  page,
  blockCount: normalizedBlocks.length,
  slotCount: normalizedSlotCount,
});
---

{isLocalDev && normalizedSlotCount > 0 ? (
  <div class="ck-localCurated" data-ck-local-curated="true" data-context={drawerContext}>
    <button
      class="ck-btn ck-btn--glass ck-btn--md label-s ck-localCurated__trigger"
      type="button"
      data-action="open"
      onclick="window.__ckLocalCuratedOpen && window.__ckLocalCuratedOpen(this)"
    >
      Curated
    </button>

    <div
      class="ck-localCurated__backdrop"
      data-action="close"
      hidden
      onclick="window.__ckLocalCuratedClose && window.__ckLocalCuratedClose(this)"
    ></div>

    <aside class="ck-localCurated__panel" data-role="panel" hidden>
      <div class="ck-localCurated__header">
        <div>
          <p class="overline ck-m0 ck-text-muted">Local Prague Tool</p>
          <h2 class="heading-5 ck-m0">Assign curated instances</h2>
          <p class="body-3 ck-m0 ck-text-muted">{widget} / {page}</p>
        </div>
        <button
          class="ck-btn ck-btn--secondary ck-btn--sm label-s"
          type="button"
          data-action="close"
          onclick="window.__ckLocalCuratedClose && window.__ckLocalCuratedClose(this)"
        >
          Close
        </button>
      </div>

      <div class="ck-localCurated__status body-3" data-role="status" data-tone="muted">
        Ready. Choose curated public IDs and save.
      </div>

      <div class="ck-localCurated__blocks" data-role="blocks">
        {normalizedBlocks.map((block) => (
          <section class="ck-localCurated__block">
            <div class="ck-localCurated__blockMeta">
              <p class="label-s ck-m0">{block.label}</p>
              <p class="caption ck-m0 ck-text-muted">{block.blockId}</p>
            </div>

            {block.slots.length > 0 ? (
              <div class="ck-localCurated__blockSlots">
                {block.slots.map((slot) => (
                  <section
                    class="ck-localCurated__slot"
                    data-slot-index={String(slot.slotIndex)}
                    data-block-id={slot.blockId}
                    data-block-type={slot.blockType}
                    data-target={slot.target}
                    data-item-index={typeof slot.itemIndex === 'number' ? String(slot.itemIndex) : ''}
                    data-original={slot.currentPublicId}
                  >
                    <label class="ck-localCurated__slotMeta" for={`ck-local-curated-slot-${slot.slotIndex}`}>
                      <span class="label-s">{slot.label}</span>
                    </label>
                    <select id={`ck-local-curated-slot-${slot.slotIndex}`} class="ck-localCurated__select body-3" data-role="select">
                      <option value={slot.currentPublicId}>{slot.currentPublicId || 'Select an instance'}</option>
                    </select>
                  </section>
                ))}
              </div>
            ) : (
              <p class="caption ck-m0 ck-localCurated__blockEmpty">No editable instance slot in this block.</p>
            )}
          </section>
        ))}
      </div>

      <div class="ck-localCurated__footer">
        <button class="ck-btn ck-btn--secondary ck-btn--sm label-s" type="button" data-action="refresh-options">
          Refresh list
        </button>
        <button class="ck-btn ck-btn--primary ck-btn--sm label-s" type="button" data-action="save" disabled>
          Save changes
        </button>
      </div>
    </aside>
  </div>
) : null}

<script is:inline>
  (function () {
    window.__ckLocalCuratedOpen = function (triggerEl) {
      const root = triggerEl && triggerEl.closest ? triggerEl.closest('.ck-localCurated') : null;
      if (!(root instanceof HTMLElement)) return;
      const panel = root.querySelector('[data-role="panel"]');
      const backdrop = root.querySelector('.ck-localCurated__backdrop');
      if (panel instanceof HTMLElement) panel.hidden = false;
      if (backdrop instanceof HTMLElement) backdrop.hidden = false;
      requestAnimationFrame(() => {
        root.classList.add('is-open');
      });
    };

    window.__ckLocalCuratedClose = function (triggerEl) {
      const root = triggerEl && triggerEl.closest ? triggerEl.closest('.ck-localCurated') : null;
      if (!(root instanceof HTMLElement)) return;
      const panel = root.querySelector('[data-role="panel"]');
      const backdrop = root.querySelector('.ck-localCurated__backdrop');
      root.classList.remove('is-open');
      window.setTimeout(() => {
        if (panel instanceof HTMLElement) panel.hidden = true;
        if (backdrop instanceof HTMLElement) backdrop.hidden = true;
      }, 180);
    };

    const roots = Array.from(document.querySelectorAll('.ck-localCurated[data-ck-local-curated="true"]'));
    roots.forEach((node) => {
      if (!(node instanceof HTMLElement)) return;
      const root = node;
      if (root.dataset.bound === '1') return;
      root.dataset.bound = '1';
      // Escape any transformed/overflow ancestors so the fixed drawer uses viewport geometry.
      if (root.parentElement !== document.body) {
        document.body.appendChild(root);
      }

      const contextRaw = root.dataset.context || '';
      const parsedContext = (() => {
        try {
          return JSON.parse(contextRaw);
        } catch {
          return null;
        }
      })();
      const context = parsedContext && typeof parsedContext === 'object' ? parsedContext : {};

      const panel = root.querySelector('[data-role="panel"]');
      const backdrop = root.querySelector('.ck-localCurated__backdrop');
      const statusEl = root.querySelector('[data-role="status"]');
      const refreshBtn = root.querySelector('[data-action="refresh-options"]');
      const saveBtn = root.querySelector('[data-action="save"]');

      if (!(panel instanceof HTMLElement) || !(backdrop instanceof HTMLElement)) return;

      const slotEls = Array.from(root.querySelectorAll('[data-slot-index]')).filter((el) => el instanceof HTMLElement);
      const blockEls = Array.from(root.querySelectorAll('.ck-localCurated__block')).filter((el) => el instanceof HTMLElement);
      const blockCount = Number.isInteger(context.blockCount) ? Number(context.blockCount) : blockEls.length;
      const slotCount = Number.isInteger(context.slotCount) ? Number(context.slotCount) : slotEls.length;

    function setStatus(message, tone) {
      if (!(statusEl instanceof HTMLElement)) return;
      statusEl.textContent = message;
      statusEl.dataset.tone = tone || 'muted';
    }

    function normalizePublicId(value) {
      return String(value || '').trim();
    }

    function readInput(slotEl) {
      const select = slotEl.querySelector('[data-role="select"]');
      if (!(select instanceof HTMLSelectElement)) return '';
      return normalizePublicId(select.value);
    }

    function setSelectOptions(slotEl, values) {
      const select = slotEl.querySelector('[data-role="select"]');
      if (!(select instanceof HTMLSelectElement)) return;

      const existing = normalizePublicId(slotEl.dataset.original || '');
      const current = normalizePublicId(select.value || existing);
      const merged = Array.from(new Set([existing, current, ...values].filter(Boolean))).sort((a, b) =>
        a.localeCompare(b),
      );

      select.innerHTML = '';
      if (merged.length === 0) {
        const empty = document.createElement('option');
        empty.value = '';
        empty.textContent = 'No instances available';
        select.appendChild(empty);
        select.value = '';
        return;
      }

      merged.forEach((value) => {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = value;
        select.appendChild(option);
      });

      if (current && merged.includes(current)) {
        select.value = current;
      } else if (existing && merged.includes(existing)) {
        select.value = existing;
      } else {
        select.value = merged[0] || '';
      }
    }

    function setSaveEnabled() {
      if (!(saveBtn instanceof HTMLButtonElement)) return;
      const changed = slotEls.some((slotEl) => {
        const nextValue = readInput(slotEl);
        const originalValue = normalizePublicId(slotEl.dataset.original || '');
        return nextValue !== originalValue;
      });
      saveBtn.disabled = !changed;
    }

    function setOptionLoading(loading) {
      if (root.dataset.busy === '1') return;
      if (refreshBtn instanceof HTMLButtonElement) refreshBtn.disabled = loading;
      slotEls.forEach((slotEl) => {
        const select = slotEl.querySelector('[data-role="select"]');
        if (select instanceof HTMLSelectElement) select.disabled = loading;
      });
      if (loading) {
        if (saveBtn instanceof HTMLButtonElement) saveBtn.disabled = true;
      } else {
        setSaveEnabled();
      }
    }

    function openPanel() {
      setSaveEnabled();
      setStatus('Found ' + slotCount + ' editable instance slots across ' + blockCount + ' blocks on this page.', 'muted');
      panel.hidden = false;
      backdrop.hidden = false;
      requestAnimationFrame(() => {
        root.classList.add('is-open');
      });
    }

    function closePanel() {
      root.classList.remove('is-open');
      window.setTimeout(() => {
        panel.hidden = true;
        backdrop.hidden = true;
      }, 180);
    }

    function setBusy(busy) {
      root.dataset.busy = busy ? '1' : '0';
      if (refreshBtn instanceof HTMLButtonElement) refreshBtn.disabled = busy;
      slotEls.forEach((slotEl) => {
        const select = slotEl.querySelector('[data-role="select"]');
        if (select instanceof HTMLSelectElement) select.disabled = busy;
      });
      if (saveBtn instanceof HTMLButtonElement) {
        if (busy) {
          saveBtn.disabled = true;
        } else {
          setSaveEnabled();
        }
      }
    }

    async function loadCuratedOptions() {
      const widget = encodeURIComponent(String(context.widget || '').trim());
      if (!widget) return;
      setOptionLoading(true);
      setStatus('Loading curated instance IDs…', 'muted');
      try {
        const res = await fetch('/api/local/curated-blocks?widget=' + widget + '&_t=' + Date.now(), {
          method: 'GET',
          cache: 'no-store',
        });
        const payload = await res.json().catch(() => ({}));
        const instances = Array.isArray(payload.instances) ? payload.instances : [];

        const values = new Set();
        slotEls.forEach((slotEl) => {
          const existing = normalizePublicId(slotEl.dataset.original || '');
          if (existing) values.add(existing);
        });
        instances.forEach((instance) => {
          const value = normalizePublicId(instance && instance.publicId);
          if (value) values.add(value);
        });

        const sortedValues = Array.from(values).sort((a, b) => a.localeCompare(b));
        slotEls.forEach((slotEl) => setSelectOptions(slotEl, sortedValues));

        const localCount = Number.isInteger(payload.localCount) ? Number(payload.localCount) : 0;
        const parisCount = Number.isInteger(payload.parisCount) ? Number(payload.parisCount) : 0;
        const warning = typeof payload.warning === 'string' && payload.warning.trim() ? payload.warning.trim() : '';

        if (instances.length > 0) {
          const sourceBreakdown =
            localCount > 0 || parisCount > 0 ? ' (' + localCount + ' local, ' + parisCount + ' Paris)' : '';
          const baseMessage =
            'Found ' +
            slotCount +
            ' editable slots across ' +
            blockCount +
            ' blocks. Loaded ' +
            instances.length +
            ' available instance IDs' +
            sourceBreakdown +
            '.';
          setStatus(warning ? baseMessage + ' ' + warning : baseMessage, warning ? 'warn' : 'ok');
        } else {
          const baseMessage =
            'Found ' + slotCount + ' editable slots across ' + blockCount + ' blocks. No instance IDs available.';
          setStatus(warning ? baseMessage + ' ' + warning : baseMessage, 'warn');
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        setStatus(
          'Found ' + slotCount + ' editable slots across ' + blockCount + ' blocks. Could not load IDs (' + message + ').',
          'warn',
        );
      } finally {
        setOptionLoading(false);
      }
    }

    async function saveChanges() {
      if (!(saveBtn instanceof HTMLButtonElement) || saveBtn.disabled) return;

      const updates = slotEls
        .map((slotEl) => {
          const publicId = readInput(slotEl);
          const original = normalizePublicId(slotEl.dataset.original || '');
          if (publicId === original) return null;
          return {
            slotEl,
            publicId,
            blockId: normalizePublicId(slotEl.dataset.blockId || ''),
            target: normalizePublicId(slotEl.dataset.target || ''),
            itemIndexRaw: normalizePublicId(slotEl.dataset.itemIndex || ''),
          };
        })
        .filter(Boolean);

      if (updates.length === 0) {
        setStatus('No changes to save.', 'muted');
        return;
      }

      const publicIdPattern = /^wgt_(curated|main)_[a-z0-9][a-z0-9_.-]*$/i;
      for (const update of updates) {
        if (!publicIdPattern.test(update.publicId)) {
          setStatus('Invalid publicId: ' + update.publicId, 'error');
          return;
        }
      }

      setBusy(true);
      setStatus('Saving ' + updates.length + ' change(s)…', 'muted');

      try {
        for (const update of updates) {
          const body = {
            widget: String(context.widget || '').trim(),
            page: String(context.page || '').trim(),
            blockId: update.blockId,
            target: update.target,
            itemIndex: update.itemIndexRaw ? Number.parseInt(update.itemIndexRaw, 10) : null,
            publicId: update.publicId,
          };

          const res = await fetch('/api/local/curated-blocks', {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify(body),
          });

          const payload = await res.json().catch(() => ({}));
          if (!res.ok) {
            const message = payload && typeof payload.message === 'string' ? payload.message : 'Request failed';
            throw new Error(message);
          }

          update.slotEl.dataset.original = update.publicId;
        }

        setStatus('Saved ' + updates.length + ' change(s). Reloading page…', 'ok');
        setSaveEnabled();
        window.setTimeout(() => {
          window.location.reload();
        }, 350);
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        setStatus('Save failed: ' + message, 'error');
        setBusy(false);
        setSaveEnabled();
        return;
      }
    }

      root.querySelector('[data-action="open"]')?.addEventListener('click', openPanel);

      root.querySelectorAll('[data-action="close"]').forEach((el) => {
        el.addEventListener('click', closePanel);
      });
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && root.classList.contains('is-open')) {
          closePanel();
        }
      });

      slotEls.forEach((slotEl) => {
        const select = slotEl.querySelector('[data-role="select"]');
        if (!(select instanceof HTMLSelectElement)) return;
        select.addEventListener('change', () => {
          setSaveEnabled();
          setStatus('Selection changed. Click "Save changes" to apply.', 'muted');
        });
      });

      refreshBtn?.addEventListener('click', () => {
        void loadCuratedOptions();
      });

      saveBtn?.addEventListener('click', () => {
        void saveChanges();
      });

      setSaveEnabled();
      void loadCuratedOptions();
    });
  })();
</script>

<style>
  .ck-localCurated {
    position: static;
  }

  .ck-localCurated__trigger {
    position: fixed;
    top: 50%;
    right: var(--space-4);
    transform: translateY(-50%);
    z-index: 1000;
    min-height: 2.625rem;
    padding-inline: var(--space-5);
  }

  .ck-localCurated__backdrop {
    position: fixed;
    inset: 0;
    background: color-mix(in oklab, var(--color-system-black), transparent 76%);
    opacity: 0;
    transition: opacity 180ms ease;
    z-index: 998;
  }

  .ck-localCurated__panel {
    position: fixed;
    inset: 0 0 0 auto;
    width: min(26rem, 94vw);
    height: 100dvh;
    max-height: 100dvh;
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
    padding: var(--space-5) var(--space-5) calc(var(--space-5) + env(safe-area-inset-bottom, 0px));
    box-sizing: border-box;
    overflow: hidden;
    background: color-mix(in oklab, var(--color-system-white), var(--color-system-gray-6) 10%);
    border-left: 1px solid color-mix(in oklab, var(--color-system-black), transparent 86%);
    box-shadow: var(--shadow-elevated);
    transform: translateX(100%);
    transition: transform 180ms ease;
    z-index: 999;
  }

  .ck-localCurated.is-open .ck-localCurated__panel {
    transform: translateX(0);
  }

  .ck-localCurated.is-open .ck-localCurated__backdrop {
    opacity: 1;
  }

  .ck-localCurated__header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: var(--space-3);
  }

  .ck-localCurated__header > div {
    display: grid;
    gap: var(--space-1);
  }

  .ck-localCurated__status {
    padding: var(--space-3);
    border-radius: var(--control-radius-lg);
    border: 1px solid color-mix(in oklab, var(--color-system-black), transparent 88%);
    background: var(--color-system-white);
    color: var(--ck-text-muted);
  }

  .ck-localCurated__status[data-tone='ok'] {
    color: color-mix(in oklab, var(--color-system-black), var(--color-system-green) 35%);
  }

  .ck-localCurated__status[data-tone='warn'] {
    color: color-mix(in oklab, var(--color-system-black), var(--color-system-orange) 45%);
  }

  .ck-localCurated__status[data-tone='error'] {
    color: color-mix(in oklab, var(--color-system-black), var(--color-system-red) 45%);
  }

  .ck-localCurated__blocks {
    flex: 1 1 auto;
    min-height: 0;
    overflow: auto;
    display: grid;
    align-content: start;
    gap: var(--space-3);
    padding-right: var(--space-1);
  }

  .ck-localCurated__block {
    display: grid;
    gap: var(--space-2);
    padding: var(--space-3);
    border-radius: var(--control-radius-lg);
    border: 1px solid color-mix(in oklab, var(--color-system-black), transparent 88%);
    background: var(--color-system-white);
  }

  .ck-localCurated__blockMeta {
    display: grid;
    gap: 2px;
  }

  .ck-localCurated__blockSlots {
    display: grid;
    gap: var(--space-2);
  }

  .ck-localCurated__blockEmpty {
    color: var(--ck-text-muted);
    padding-top: 2px;
  }

  .ck-localCurated__slot {
    display: grid;
    gap: 6px;
  }

  .ck-localCurated__slotMeta {
    display: grid;
    gap: 2px;
    color: var(--color-system-black);
  }

  .ck-localCurated__select {
    width: 100%;
    box-sizing: border-box;
    min-height: 2.5rem;
    border-radius: var(--control-radius-md);
    border: 1px solid color-mix(in oklab, var(--color-system-black), transparent 80%);
    padding: 0 var(--space-3);
    color: var(--color-system-black);
    background: var(--color-system-white);
    appearance: auto;
    max-width: 100%;
  }

  .ck-localCurated__select:focus-visible {
    outline: var(--focus-ring-width) solid var(--color-system-blue);
    outline-offset: var(--focus-ring-offset);
  }

  .ck-localCurated__footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--space-2);
    padding-top: var(--space-2);
    border-top: 1px solid color-mix(in oklab, var(--color-system-black), transparent 88%);
  }

  @media (max-width: 900px) {
    .ck-localCurated__trigger {
      top: auto;
      bottom: var(--space-4);
      right: var(--space-4);
      transform: none;
      min-height: 2.5rem;
      padding-inline: var(--space-4);
    }

    .ck-localCurated__panel {
      width: min(100vw, 26rem);
    }
  }
</style>
