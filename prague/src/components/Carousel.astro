---
import InstanceEmbed from './InstanceEmbed.astro';

type CarouselItem = {
  curatedRef: {
    publicId: string;
    locale: string;
    title?: string;
    embedMode?: 'iframe' | 'indexable';
  };
};

type Props = {
  items: CarouselItem[];
  id?: string;
};

const { items, id = `carousel-${Math.random().toString(36).substr(2, 9)}` } = Astro.props;
---

<div class="ck-carousel">
  {items && items.length > 0 ? (
    <>
      <div class="ck-carousel__viewport">
        <div class="ck-carousel__track" id={id}>
          {items.concat(items[0]).map((item, index) => (
            <div class="ck-carousel__item" data-index={index}>
              {item.curatedRef ? (
                <InstanceEmbed
                  publicId={item.curatedRef.publicId}
                  locale={item.curatedRef.locale}
                  title={item.curatedRef.title ?? `Widget preview ${index + 1}`}
                  embedMode={item.curatedRef.embedMode}
                  loading="eager"
                />
              ) : (
                <div class="ck-media ck-carousel__stub">Missing curatedRef</div>
              )}
            </div>
          ))}
        </div>

      </div>

      <div class="ck-carousel__dots">
        {items.map((_, index) => (
          <button
            class={`ck-carousel__dot ${index === 0 ? 'ck-carousel__dot--active' : ''}`}
            aria-label={`Go to slide ${index + 1}`}
            data-target={index}
          />
        ))}
      </div>
    </>
  ) : (
    <div class="ck-media ck-carousel__stub">No items provided</div>
  )}
</div>

<script>
  function initCarousel(carouselId: string) {
    const track = document.getElementById(carouselId);
    if (!track) return;

    const viewport = track.parentElement;
    if (!viewport || !viewport.classList.contains('ck-carousel__viewport')) return;

    const dotsContainer = viewport.nextElementSibling as HTMLElement;
    if (!dotsContainer || !dotsContainer.classList.contains('ck-carousel__dots')) return;



    const dots = Array.from(dotsContainer.children) as HTMLButtonElement[];
    const items = Array.from(track.children) as HTMLElement[];
    const realItemCount = items.length - 1; // Last item is a clone
    let currentIndex = 0;
    let autoScrollInterval: number | undefined;
    let userIsScrolling = false;
    const AUTO_SCROLL_DELAY = 3000;

    const supportsScrollend = 'onscrollend' in window;

    // ── Helpers ─────────────────────────────────────────────
    const updateDots = (index: number) => {
      const normalizedIndex = index >= realItemCount ? 0 : index;
      dots.forEach((dot, i) => {
        dot.classList.toggle('ck-carousel__dot--active', i === normalizedIndex);
      });
    };

    const scrollToItem = (index: number, behavior: ScrollBehavior = 'smooth') => {
      const item = items[index];
      if (!item) return;

      // Chrome: scroll-snap-type: mandatory fights scrollTo({ behavior: 'smooth' }).
      // Temporarily disable snap, scroll, then re-enable after the scroll finishes.
      if (behavior === 'smooth') {
        track.style.scrollSnapType = 'none';
      }

      track.scrollTo({
        left: item.offsetLeft - track.offsetLeft,
        behavior,
      });
      currentIndex = index;
      updateDots(index);

      if (behavior === 'smooth') {
        waitForScrollEnd(() => {
          track.style.scrollSnapType = '';
        });
      }
    };

    function waitForScrollEnd(cb: () => void) {
      const el = track!;
      if (supportsScrollend) {
        el.addEventListener('scrollend', () => cb(), { once: true });
      } else {
        let lastLeft = el.scrollLeft;
        let stableFrames = 0;
        function check() {
          const curLeft = el.scrollLeft;
          if (curLeft === lastLeft) {
            stableFrames++;
            if (stableFrames >= 3) { cb(); return; }
          } else {
            stableFrames = 0;
          }
          lastLeft = curLeft;
          requestAnimationFrame(check);
        }
        requestAnimationFrame(check);
      }
    }

    const nextSlide = () => {
      if (userIsScrolling) return;
      const nextIndex = currentIndex + 1;
      if (nextIndex >= realItemCount) {
        // Infinite loop: scroll to clone, then jump back to real first slide.
        // Handle snap disable/re-enable manually to avoid competing callbacks.
        track.style.scrollSnapType = 'none';
        const cloneItem = items[nextIndex];
        if (!cloneItem) return;
        track.scrollTo({
          left: cloneItem.offsetLeft - track.offsetLeft,
          behavior: 'smooth',
        });
        currentIndex = nextIndex;
        updateDots(nextIndex);
        waitForScrollEnd(() => {
          // Jump instantly to real first slide, then restore snap
          const firstItem = items[0];
          if (firstItem) {
            track.scrollTo({ left: firstItem.offsetLeft - track.offsetLeft, behavior: 'auto' });
          }
          currentIndex = 0;
          updateDots(0);
          track.style.scrollSnapType = '';
        });
      } else {
        scrollToItem(nextIndex, 'smooth');
      }
    };

    const prevSlide = () => {
      if (currentIndex <= 0) {
        scrollToItem(realItemCount - 1, 'smooth');
      } else {
        scrollToItem(currentIndex - 1, 'smooth');
      }
    };

    // ── Auto-scroll ────────────────────────────────────────
    const startAutoScroll = () => {
      stopAutoScroll();
      autoScrollInterval = window.setInterval(nextSlide, AUTO_SCROLL_DELAY);
    };

    const stopAutoScroll = () => {
      if (autoScrollInterval) {
        clearInterval(autoScrollInterval);
        autoScrollInterval = undefined;
      }
    };



    // ── Dot buttons ────────────────────────────────────────
    dots.forEach((dot, index) => {
      dot.addEventListener('click', () => {
        stopAutoScroll();
        scrollToItem(index, 'smooth');
        startAutoScroll();
      });
    });

    // ── Pause on hover / touch ─────────────────────────────
    viewport.addEventListener('mouseenter', stopAutoScroll);
    viewport.addEventListener('mouseleave', startAutoScroll);
    viewport.addEventListener('touchstart', stopAutoScroll, { passive: true });
    viewport.addEventListener('touchend', () => setTimeout(startAutoScroll, 1000));

    // ── Manual scroll detection ────────────────────────────
    let scrollTimer: number | undefined;
    track.addEventListener('scroll', () => {
      userIsScrolling = true;
      stopAutoScroll();

      if (scrollTimer) window.clearTimeout(scrollTimer);
      scrollTimer = window.setTimeout(() => {
        userIsScrolling = false;

        const trackCenter = track.scrollLeft + track.offsetWidth / 2;
        let closestIndex = 0;
        let minDistance = Infinity;

        items.forEach((item, index) => {
          const itemCenter = item.offsetLeft + item.offsetWidth / 2;
          const distance = Math.abs(trackCenter - itemCenter);
          if (distance < minDistance) {
            minDistance = distance;
            closestIndex = index;
          }
        });

        if (closestIndex >= realItemCount) {
          scrollToItem(0, 'auto');
        } else if (closestIndex !== currentIndex) {
          currentIndex = closestIndex;
          updateDots(currentIndex);
        }

        startAutoScroll();
      }, 120);
    }, { passive: true });

    startAutoScroll();
  }

  const tracks = document.querySelectorAll('.ck-carousel__track');
  tracks.forEach(track => {
    if (track.id) initCarousel(track.id);
  });
</script>

<style>
  .ck-carousel__viewport {
    position: relative;
  }

  .ck-carousel__track {
    display: flex;
    gap: var(--space-4);
    overflow-x: auto;
    scroll-snap-type: x mandatory;
    padding-bottom: var(--space-4);
    width: 100%;
    scrollbar-width: none;
    -ms-overflow-style: none;
    position: relative;
  }

  .ck-carousel__track::-webkit-scrollbar {
    display: none;
  }

  .ck-carousel__item {
    scroll-snap-align: center;
    flex: 0 0 100%;
    min-width: 0;
    scroll-margin: 0 var(--space-4);
    pointer-events: none;
  }


  /* ── Stub ── */
  .ck-carousel__stub {
    width: 100%;
    min-height: 280px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: color-mix(in oklab, var(--color-system-black), transparent 56%);
    background: var(--color-system-cloud);
    border-radius: var(--radius-lg);
  }

  /* ── Dots ── */
  .ck-carousel__dots {
    display: flex;
    justify-content: center;
    gap: var(--space-2);
    margin-top: var(--space-4);
  }

  .ck-carousel__dot {
    width: 8px;
    height: 8px;
    border-radius: 100px;
    background-color: color-mix(in oklab, var(--color-system-black), transparent 80%);
    border: none;
    padding: 0;
    cursor: pointer;
    transition: background-color 0.3s ease, width 0.3s ease;
  }

  .ck-carousel__dot:hover {
     background-color: color-mix(in oklab, var(--color-system-black), transparent 60%);
  }

  .ck-carousel__dot--active {
    background-color: var(--color-system-black);
    width: 24px;
  }
</style>
