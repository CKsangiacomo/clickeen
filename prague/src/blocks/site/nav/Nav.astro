---
import { resolveWidgetsMegaMenu } from './widgetsMegaMenu';
import { pragueT } from '../../../lib/i18n';

type Props = {
  title: string;
  locale: string;
  homeHref?: string;
  // Legacy escape hatch: some pages may still pass items, but the scalable default is system-owned nav.
  items?: { label: string; href: string }[];
  cta?: { label: string; href: string; variant?: 'primary' | 'secondary' };
  /**
   * Nav surface model:
   * - overlay: transparent at top-of-page; becomes surfaced when stuck (default)
   * - solid: always surfaced (use on non-hero pages if desired)
   */
  surface?: 'overlay' | 'solid';
  /** Enable sticky behavior (visual + position). Default true. */
  sticky?: boolean;
  /**
   * Floating mode (true "overlay"):
   * - At top-of-page, nav overlays the top surface (absolute).
   * - Once stuck, nav pins to viewport (fixed) and can become surfaced.
   */
  floating?: boolean;
};

const { title, locale, homeHref = `/${locale}/`, items: itemsProp, cta } = Astro.props;
const ctaVariant = cta?.variant ?? 'secondary';
const navSurface = (Astro.props.surface ?? 'overlay') as NonNullable<Props['surface']>;
const navSticky = Astro.props.sticky !== false;
const navFloating = Astro.props.floating === true;

const widgetsLabel = pragueT(locale, 'prague.nav.widgets');

const mega = await resolveWidgetsMegaMenu({ locale });

type PrimaryItem =
  | { kind: 'widgets' }
  | { kind: 'link'; label: string; href: string }
  | { kind: 'stub'; label: string };

const primaryItems: PrimaryItem[] = itemsProp
  ? [{ kind: 'widgets' }, ...itemsProp.map((i) => ({ kind: 'link', label: i.label, href: i.href }) as const)]
  : [
      { kind: 'widgets' },
      { kind: 'stub', label: 'Pricing' },
      { kind: 'stub', label: 'Docs' },
    ];

const widgetCategories: { label: string }[] = [
  { label: 'Social proof' },
  { label: 'Lead capture' },
  { label: 'Engagement' },
  { label: 'Info' },
];
---

<header
  class="ck-canvas ck-siteNavHeader"
  data-nav-surface={navSurface}
  data-nav-sticky={navSticky ? 'true' : 'false'}
  data-nav-stuck="false"
  data-nav-floating={navFloating ? 'true' : 'false'}
>
  <div class="ck-inline">
    <div class="ck-row ck-siteNav">
      <a href={homeHref} class="ck-brand" aria-label={title}>
        <img class="ck-brand__logo" src="/brand/clickeen-logo-full.svg" alt={title} />
      </a>

      <nav aria-label="Primary">
        <div class="ck-row ck-siteNav__primary">
          {primaryItems.map((item) => {
            if (item.kind === 'widgets') {
              return (
                <details class="ck-mega" data-ck-mega="widgets">
                  <summary class="label-s ck-siteNav__link ck-mega__trigger" aria-haspopup="dialog">
                    {widgetsLabel}
                  </summary>

                  {/* Backdrop captures outside clicks and blocks interaction with page UI under the curtain. */}
                  <button class="ck-mega__backdrop" type="button" aria-label="Close widgets menu" data-ck-mega-close />

                  <div class="ck-mega__curtain" role="dialog" aria-label="Widgets menu">
                    <div class="ck-inline">
                      <div class="ck-mega__layout">
                        <div class="ck-mega__rail">
                          <div class="caption ck-mega__railTitle">Browse</div>
                          <div class="ck-stack ck-mega__railList">
                            {widgetCategories.map((c, idx) => (
                              <div class={`label-s ck-mega__railItem${idx === 0 ? ' is-active' : ''}`}>
                                {c.label}
                              </div>
                            ))}
                          </div>
                        </div>

                        <div class="ck-mega__main">
                          <div class="ck-mega__grid">
                            {mega.items.map((w) => (
                              <a class="ck-mega__item" href={w.href}>
                                <div class="label-s">{w.headline}</div>
                                <div class="caption ck-mega__sub">{w.subheadline}</div>
                              </a>
                            ))}
                          </div>
                        </div>

                        <div class="ck-mega__aside">
                          <div class="ck-stack ck-mega__asideInner">
                            <div class="label-m">Try without an account</div>
                            <div class="caption ck-mega__asideBody">
                              Customize a widget instantly. Publish when you’re ready.
                            </div>
                            <a class="ck-btn ck-btn--secondary ck-btn--md label-m" href={mega.allWidgetsHref}>
                              {pragueT(locale, 'prague.nav.viewAllWidgets')}
                            </a>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </details>
              );
            }

            if (item.kind === 'link') {
              return (
                <a href={item.href} class="label-s ck-siteNav__link">
                  {item.label}
                </a>
              );
            }

            return (
              <span class="label-s ck-siteNav__link is-disabled" aria-disabled="true">
                {item.label}
              </span>
            );
          })}
        </div>
      </nav>

      {cta ? (
        <a class={`ck-btn ck-btn--${ctaVariant} ck-btn--md label-m`} href={cta.href}>
          {cta.label}
        </a>
      ) : (
        <span aria-hidden="true" />
      )}
    </div>
  </div>
</header>

<style>
  .ck-siteNav { position: relative; }

  /* Nav state machine (global, scalable):
     - surface: overlay | solid
     - stuck: false | true
     This keeps page-level styling out of page templates and prevents drift. */
  .ck-siteNavHeader {
    padding-block: var(--space-5);
    position: sticky;
    top: 0;
    z-index: 60;
    width: 100%;

    /* Default (overlay) values */
    --ck-nav-bg: transparent;
    --ck-nav-border: transparent;
    --ck-nav-shadow: none;
    --ck-nav-backdrop: none;

    background: var(--ck-nav-bg);
    border-bottom: 1px solid var(--ck-nav-border);
    box-shadow: var(--ck-nav-shadow);
    backdrop-filter: var(--ck-nav-backdrop);
    -webkit-backdrop-filter: var(--ck-nav-backdrop);
  }

  .ck-siteNavHeader[data-nav-sticky="false"] {
    position: relative;
    top: auto;
  }

  /* Floating overlay mode (true overlap in code). */
  .ck-siteNavHeader[data-nav-floating="true"] {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
  }

  .ck-siteNavHeader[data-nav-floating="true"][data-nav-stuck="true"] {
    position: fixed;
  }

  /* Solid surface (always) */
  .ck-siteNavHeader[data-nav-surface="solid"] {
    --ck-nav-bg: color-mix(in oklab, var(--color-system-white), transparent 6%);
    --ck-nav-border: color-mix(in oklab, var(--color-system-black), transparent 90%);
    --ck-nav-shadow: 0 8px 22px color-mix(in oklab, var(--color-system-black), transparent 94%);
    --ck-nav-backdrop: blur(14px);
  }

  /* Overlay surface: becomes surfaced only when stuck */
  .ck-siteNavHeader[data-nav-surface="overlay"][data-nav-stuck="true"] {
    --ck-nav-bg: color-mix(in oklab, var(--color-system-white), transparent 6%);
    --ck-nav-border: color-mix(in oklab, var(--color-system-black), transparent 90%);
    --ck-nav-shadow: 0 8px 22px color-mix(in oklab, var(--color-system-black), transparent 94%);
    --ck-nav-backdrop: blur(14px);
  }

  .ck-siteNav {
    justify-content: space-between;
    gap: var(--space-6);
  }

  .ck-siteNav__primary { gap: var(--space-5); }

  .ck-siteNav__link {
    text-decoration: none;
    color: color-mix(in oklab, var(--color-system-black), transparent 25%);
  }
  .ck-siteNav__link.is-disabled {
    opacity: 0.55;
    cursor: default;
    user-select: none;
  }
  .ck-brand { display: inline-flex; align-items: center; text-decoration: none; color: inherit; }
  .ck-brand__logo { height: 22px; width: auto; display: block; }

  /* Square-style mega dropdown (curtain) */
  .ck-mega { position: relative; }

  .ck-mega__trigger {
    display: inline-flex;
    align-items: center;
    gap: var(--space-2);
    cursor: pointer;
    user-select: none;
  }
  .ck-mega__trigger::after {
    content: "▾";
    font-size: 10px;
    line-height: 1;
    margin-left: 2px;
    color: color-mix(in oklab, var(--color-system-black), transparent 45%);
    transform: translateY(-1px);
    transition: transform var(--duration-base) var(--easing-standard);
  }
  .ck-mega[open] .ck-mega__trigger::after { transform: rotate(180deg) translateY(1px); }

  .ck-mega__trigger::-webkit-details-marker { display: none; }
  .ck-mega__trigger::marker { content: ''; }

  .ck-mega__backdrop {
    display: none;
    position: fixed;
    left: 0;
    right: 0;
    top: var(--ck-nav-h, 72px);
    bottom: 0;
    background: transparent;
    border: 0;
    padding: 0;
    margin: 0;
    z-index: 55;
    cursor: default;
  }

  .ck-mega__curtain {
    display: none;
    position: fixed;
    left: 0;
    right: 0;
    top: var(--ck-nav-h, 72px);
    max-height: calc(100vh - var(--ck-nav-h, 72px));
    overflow: auto;
    background: var(--color-system-white);
    border-top: 1px solid color-mix(in oklab, var(--color-system-black), transparent 88%);
    box-shadow: 0 22px 90px color-mix(in oklab, var(--color-system-black), transparent 90%);
    z-index: 56;
    padding-block: var(--space-7);
    transform-origin: top;
  }

  .ck-mega[open] .ck-mega__backdrop,
  .ck-mega[open] .ck-mega__curtain {
    display: block;
    animation: ckMegaIn var(--duration-base) var(--easing-standard) both;
  }

  @keyframes ckMegaIn {
    from { opacity: 0; transform: translateY(-6px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .ck-mega__layout {
    display: grid;
    grid-template-columns: 220px minmax(0, 1fr) 280px;
    gap: var(--space-8);
    align-items: start;
  }

  .ck-mega__railTitle {
    text-transform: uppercase;
    letter-spacing: 0.08em;
    opacity: 0.7;
  }

  .ck-mega__railList { gap: 8px; margin-top: var(--space-4); }

  .ck-mega__railItem {
    padding: 8px 10px;
    border-radius: var(--control-radius-md);
    color: color-mix(in oklab, var(--color-system-black), transparent 35%);
  }
  .ck-mega__railItem.is-active {
    background: color-mix(in oklab, var(--color-system-black), transparent 92%);
    color: var(--color-system-black);
  }

  .ck-mega__main {
    /* Prevent huge dead space when we have few widgets. */
    max-width: 820px;
  }

  .ck-mega__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: var(--space-3);
  }

  .ck-mega__item {
    display: block;
    padding: var(--space-4);
    border-radius: var(--control-radius-lg);
    text-decoration: none;
    color: var(--color-system-black);
    background: color-mix(in oklab, var(--color-system-black), transparent 96%);
    transition: background var(--duration-base) var(--easing-standard);
  }
  .ck-mega__item:hover {
    background: color-mix(in oklab, var(--color-system-black), transparent 92%);
  }

  .ck-mega__sub {
    margin-top: 6px;
    color: color-mix(in oklab, var(--color-system-black), transparent 55%);
  }

  .ck-mega__asideInner {
    padding: var(--space-5);
    border-radius: var(--control-radius-xl);
    border: 1px solid color-mix(in oklab, var(--color-system-black), transparent 90%);
    background: color-mix(in oklab, var(--color-system-black), transparent 97%);
    gap: var(--space-3);
  }

  .ck-mega__asideBody {
    color: color-mix(in oklab, var(--color-system-black), transparent 55%);
  }

  @media (max-width: 900px) {
    .ck-brand__logo { height: 20px; }
    .ck-mega__layout { grid-template-columns: 1fr; gap: var(--space-6); }
    .ck-mega__grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
  }

  @media (max-width: 640px) {
    .ck-mega__grid { grid-template-columns: 1fr; }
  }
</style>

{navSticky ? (
  <script>
    {`
(() => {
  const header = document.querySelector('.ck-siteNavHeader[data-nav-sticky="true"]');
  if (!header) return;

  const surface = header.closest('.ck-topSurface');
  const heightTarget = surface || document.documentElement;
  const syncHeight = () => {
    const h = Math.ceil(header.getBoundingClientRect().height);
    heightTarget.style.setProperty('--ck-nav-h', h ? (h + 'px') : '0px');
  };

  // Toggle "stuck" styling when the page scrolls. Keep the controller tiny and deterministic.
  const update = () => {
    const stuck = window.scrollY > 8;
    header.setAttribute('data-nav-stuck', stuck ? 'true' : 'false');
  };

  syncHeight();
  update();

  if ('ResizeObserver' in window) {
    const ro = new ResizeObserver(() => syncHeight());
    ro.observe(header);
  } else {
    window.addEventListener('resize', syncHeight, { passive: true });
  }

  window.addEventListener('scroll', update, { passive: true });
})();
`}
  </script>
) : null}

<script>
  {`
(() => {
  const mega = document.querySelector('details.ck-mega[data-ck-mega="widgets"]');
  if (!mega) return;

  const isHoverCapable = () => window.matchMedia && window.matchMedia('(hover: hover)').matches;

  const open = () => {
    mega.open = true;
  };
  const close = () => {
    mega.open = false;
  };

  // Close on backdrop click.
  const backdrop = mega.querySelector('[data-ck-mega-close]');
  if (backdrop) {
    backdrop.addEventListener('click', (e) => {
      e.preventDefault();
      close();
    });
  }

  // Close on Escape.
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') close();
  });

  // Close when clicking a destination (navigation will proceed).
  mega.addEventListener('click', (e) => {
    const t = e.target;
    if (!(t instanceof Element)) return;
    if (t.closest('.ck-mega__item') || t.closest('.ck-mega__asideInner a')) {
      close();
    }
  });

  // Hover open/close (desktop only). Mirrors “curtain” behavior.
  // IMPORTANT: use bubbling events so entering the fixed-position curtain counts as "still hovered".
  let closeTimer = null;
  const scheduleClose = () => {
    if (closeTimer) clearTimeout(closeTimer);
    closeTimer = setTimeout(() => close(), 140);
  };
  const cancelClose = () => {
    if (closeTimer) clearTimeout(closeTimer);
    closeTimer = null;
  };

  mega.addEventListener('mouseover', (e) => {
    if (!isHoverCapable()) return;
    const t = e.target;
    if (!(t instanceof Element)) return;
    if (mega.contains(t)) {
      cancelClose();
      open();
    }
  });

  mega.addEventListener('mouseout', (e) => {
    if (!isHoverCapable()) return;
    const rt = e.relatedTarget;
    if (!(rt instanceof Element) || !mega.contains(rt)) {
      scheduleClose();
    }
  });
})();
`}
</script>
