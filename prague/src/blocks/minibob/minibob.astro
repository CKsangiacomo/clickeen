---
import { assertPrimitives } from '@clickeen/composition';
import PrimitiveRenderer from '@clickeen/composition/renderers/astro/PrimitiveRenderer.astro';
import { loadWidgetLocalizationAllowlistPaths } from '../../lib/widgetLocalizationAllowlist';
import PersonalizationPreview from '../../components/PersonalizationPreview.astro';

type Props = {
  widget: string;
  locale: string;
  page: string;
  heading: string;
  subhead: string;
};

const { widget, locale, page, heading, subhead } = Astro.props;

const headerPrimitives = assertPrimitives(
  [
    {
      type: 'heading',
      level: 2,
      content: heading,
      className: 'display-2 ck-m0 ck-minibobStage__title',
    },
    {
      type: 'text',
      variant: 'body',
      content: subhead,
      className: 'body-website ck-m0 ck-minibobStage__subhead ck-text-secondary',
    },
  ],
  'minibob.header',
);

const BOB_URL = import.meta.env.PUBLIC_BOB_URL ?? process.env.PUBLIC_BOB_URL;
if (!BOB_URL) {
  throw new Error('[prague] PUBLIC_BOB_URL is required (e.g. http://localhost:3000)');
}

const DEV_WORKSPACE_ID = '00000000-0000-0000-0000-000000000001';
const widgetKey = widget.toUpperCase().replace(/[^A-Z0-9]/g, '_');
const env = typeof process !== 'undefined' ? process.env : {};
const workspaceId = String(
  env[`PUBLIC_MINIBOB_WORKSPACE_ID_${widgetKey}`] ?? env.PUBLIC_MINIBOB_WORKSPACE_ID ?? DEV_WORKSPACE_ID,
).trim();
const publicId = `wgt_main_${widget}`;
const iframeSrc = `${BOB_URL.replace(/\/+$/, '')}/bob?boot=url&subject=minibob&workspaceId=${encodeURIComponent(workspaceId)}&publicId=${encodeURIComponent(publicId)}&locale=${encodeURIComponent(locale)}`;
const iframeId = `ck-minibob-${widget}-${locale}`.replace(/[^a-z0-9_-]/gi, '-');
const createHref = (() => {
  try {
    const parts = Astro.url.pathname.split('/').filter(Boolean);
    const marketKey = parts[0] || 'us';
    const localeKey = parts[1] || locale || 'en';
    return `/${marketKey}/${localeKey}/create`;
  } catch {
    return `/${locale || 'en'}/create`;
  }
})();
const bobOrigin = (() => {
  try {
    return new URL(BOB_URL).origin;
  } catch {
    return '';
  }
})();

// Load allowlist for this widget type so PersonalizationPreview knows what AI can touch
const allowedOverrides = (await loadWidgetLocalizationAllowlistPaths(widget)) ?? undefined;
---

<section
  id="minibob"
  class="ck-canvas"
  data-bob-origin={bobOrigin}
  data-create-href={createHref}
  data-public-id={publicId}
>
  <div class="ck-minibobStage ck-stack ck-gap-tight">
    <PrimitiveRenderer primitives={headerPrimitives} />
    <div class="ck-minibobStage__personalize">
      <PersonalizationPreview
        locale={locale}
        widget={widget}
        page={page}
        variant="embed"
        publicId={publicId}
        targetIframeId={iframeId}
        allowedOverrides={allowedOverrides}
      />
    </div>
  </div>

  <div class="ck-inline">
    <iframe
      id={iframeId}
      class="ck-minibob__iframe"
      title="Minibob"
      src={iframeSrc}
      loading="lazy"
      referrerpolicy="no-referrer"
      sandbox="allow-scripts allow-same-origin allow-forms"
    />
  </div>
</section>

<script is:inline>
  (() => {
    const root = document.getElementById('minibob');
    if (!(root instanceof HTMLElement)) return;
    if (root.dataset.ckUpsellBound === '1') return;
    root.dataset.ckUpsellBound = '1';

    const expectedOrigin = root.dataset.bobOrigin || '';
    const signupHref = root.dataset.createHref || '';
    const fallbackPublicId = (root.dataset.publicId || '').trim();
    const HANDOFF_START_ENDPOINT = '/api/minibob/handoff-start';
    const EXPORT_TIMEOUT_MS = 8000;
    let handoffInFlight = false;

    const iframe = root.querySelector('iframe.ck-minibob__iframe');
    if (!(iframe instanceof HTMLIFrameElement)) return;

    const asRecord = (value) => (value && typeof value === 'object' && !Array.isArray(value) ? value : null);
    const asText = (value) => (typeof value === 'string' ? value.trim() : '');

    const nextRequestId = () => {
      if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
        return `handoff_${crypto.randomUUID()}`;
      }
      return `handoff_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
    };

    async function exportHandoffContextFromBob() {
      if (!iframe.contentWindow) throw new Error('bob iframe not ready');

      const requestId = nextRequestId();
      const response = await new Promise((resolve, reject) => {
        let timeoutId = null;

        const done = (err, payload) => {
          if (timeoutId != null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          window.removeEventListener('message', onMessage);
          if (err) {
            reject(err);
            return;
          }
          resolve(payload);
        };

        const onMessage = (event) => {
          if (expectedOrigin && event.origin !== expectedOrigin) return;
          if (event.source !== iframe.contentWindow) return;
          const data = asRecord(event.data);
          if (!data || data.type !== 'bob:export-instance-data') return;
          if (asText(data.requestId) !== requestId) return;
          if (data.ok !== true) {
            done(new Error(asText(data.error) || 'bob export failed'));
            return;
          }
          done(null, data);
        };

        timeoutId = window.setTimeout(() => {
          done(new Error('bob export timeout'));
        }, EXPORT_TIMEOUT_MS);

        window.addEventListener('message', onMessage);
        iframe.contentWindow.postMessage(
          {
            type: 'devstudio:export-instance-data',
            requestId,
            exportMode: 'current',
            persistAssets: false,
          },
          expectedOrigin || '*',
        );
      });

      const payload = asRecord(response);
      const meta = asRecord(payload?.meta);
      const publicId = asText(meta?.publicId) || fallbackPublicId;
      if (!publicId) throw new Error('missing publicId for handoff');

      const widgetType = asText(meta?.widgetname) || undefined;
      const isDirty = payload?.isDirty === true;
      const draftConfig = isDirty ? asRecord(payload?.instanceData) : undefined;
      if (isDirty && !draftConfig) {
        throw new Error('missing draft config for dirty minibob session');
      }

      return {
        publicId,
        widgetType,
        draftConfig,
      };
    }

    async function startHandoff(input) {
      const response = await fetch(HANDOFF_START_ENDPOINT, {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
        },
        body: JSON.stringify(input),
      });
      const payload = await response.json().catch(() => null);
      if (!response.ok) {
        const detail = asRecord(payload);
        throw new Error(asText(detail?.message) || asText(detail?.error) || `handoff start failed (${response.status})`);
      }
      const body = asRecord(payload);
      const handoffId = asText(body?.handoffId);
      if (!handoffId) throw new Error('handoff start returned empty id');
      return handoffId;
    }

    function buildSignupUrl(baseHref, args) {
      const url = new URL(baseHref, window.location.href);
      url.searchParams.set('handoffId', args.handoffId);
      url.searchParams.set('publicId', args.publicId);
      return url.toString();
    }

    function surfaceHandoffError(error) {
      const message = error instanceof Error ? error.message : String(error);
      console.error('[prague:minibob] minibob handoff failed', message);
      window.alert(`Unable to continue signup from MiniBob right now. ${message}`);
    }

    window.addEventListener('message', (event) => {
      if (expectedOrigin && event.origin !== expectedOrigin) return;
      if (event.source !== iframe.contentWindow) return;
      const data = event.data;
      if (!data || typeof data !== 'object') return;
      if (data.type !== 'bob:upsell') return;
      if (data.cta !== 'signup') return;
      if (!signupHref) return;

      if (handoffInFlight) return;
      handoffInFlight = true;

      (async () => {
        const handoffInput = await exportHandoffContextFromBob();
        const handoffId = await startHandoff(handoffInput);
        const nextUrl = buildSignupUrl(signupHref, { handoffId, publicId: handoffInput.publicId });
        window.location.assign(nextUrl);
      })().catch((error) => {
        handoffInFlight = false;
        surfaceHandoffError(error);
      });
    });
  })();
</script>

<style>
  #minibob.ck-canvas {
    background: var(--color-system-white);
  }

  .ck-minibobStage {
    max-width: var(--prague-max);
    margin-inline: auto;
    padding-inline: var(--prague-gutter);
    margin-bottom: var(--space-6);
    text-align: center;
  }

  .ck-minibobStage__personalize {
    display: flex;
    justify-content: center;
    margin-top: var(--space-4);
  }

  .ck-minibob__iframe {
    width: 100%;
    height: clamp(520px, 78vh, 920px);
    border: 0;
    border-radius: var(--control-radius-lg);
    box-shadow: none;
    background: var(--color-system-white);
  }

  @supports (height: 1svh) {
    .ck-minibob__iframe {
      height: clamp(520px, 78svh, 920px);
    }
  }

  @media (max-width: 900px) {
    .ck-minibobStage { margin-bottom: var(--space-5); }
  }
</style>
