# Prague Widget Pages / Blocks Localization (Owned Surface)

Status: deprecated in favor of the prague-strings pipeline defined in `Execution_Pipeline_Docs/00-Strategy/026__Localization_PragueCopy_Base_Overlays_Manifest.md`.

**Status:** execution plan / spec

Prague marketing pages and blocks are **Clickeen-owned surfaces**. They are repo-defined JSON artifacts (Tokyo) rendered by Prague. Localization here should be simple, deterministic, and scalable: **manual locale base variants for full control**, otherwise **set-only overlays** generated by San Francisco and applied at render/build time.

---

## Non‑Negotiable Tenets (System Contracts)

1. **Locale is runtime, not identity**
   - No locale in IDs, URLs, keys, or storage identity.

2. **Files are truth for Prague content**
   - Base pages/blocks live in widget folders under Tokyo.

3. **Manual locale base variants are authoritative**
   - If a locale-specific full JSON exists, it wins and no overlay is applied.

4. **Overlays are set-only ops**
   - Only `{ op: "set" }`.
   - No structural edits (no insert/remove/move, no array length changes).

5. **Deterministic staleness guard (one language everywhere)**
   - `baseFingerprint = sha256(stableStringify(baseDoc))`
   - Apply overlay only if `overlay.baseFingerprint === computeBaseFingerprint(baseDoc)`.

6. **Derived artifacts live in Tokyo (not git long-term)**
   - Overlays/manifests are generated artifacts served by Tokyo (CDN/R2 in cloud-dev).
   - Local dev remains deterministic because the local Tokyo dev server serves from filesystem when present.

---

## Owned Surface Model (Files + Paths)

### Base content (authoritative)

- **Base pages**
  - `tokyo/widgets/{widget}/pages/{page}.json`

- **Base blocks**
  - `tokyo/widgets/{widget}/blocks/{block}.json`

> If Prague’s implementation stores blocks inside page JSON (common), keep `blocks/` optional. The localization contract remains identical; only the base file path changes.

### Manual locale base variants (authoritative per locale)

- Pages:
  - `tokyo/widgets/{widget}/pages/.locales/{locale}/{page}.json`
- Blocks:
  - `tokyo/widgets/{widget}/blocks/.locales/{locale}/{block}.json`

**Rule:** If the manual locale base variant exists, Prague uses it and stops.

### Overlays (derived)

- Pages:
  - `tokyo/l10n/pages/{widget}/{page}/manifest.json`
  - `tokyo/l10n/pages/{widget}/{page}/{locale}.{baseFingerprint}.ops.json`

- Blocks:
  - `tokyo/l10n/blocks/{widget}/{block}/manifest.json`
  - `tokyo/l10n/blocks/{widget}/{block}/{locale}.{baseFingerprint}.ops.json`

---

## Path Syntax Contract (Allowlist ⇄ Ops ⇄ Prague)

We use one path language everywhere.

- **Object keys:** dot notation, e.g. `copy.headline`.
- **Array access:**
  - Allowlists may use wildcard `[*]` only (never numeric indices).
  - Generated ops must use **concrete indices** (e.g. `blocks[0].copy.headline`).
- **No shape changes:**
  - paths may only target existing nodes in the base JSON.
  - arrays: only set values at existing indices.

---

## Per-System Responsibilities (Minimal + Scalable)

### Tokyo (storage + serving)

Tokyo stores and serves:
- base pages/blocks
- optional manual locale base variants
- allowlists
- derived l10n overlays + manifests

Tokyo does not “decide” localization. It’s a deterministic file plane.

### San Francisco (generation)

For each job `(kind, widget, pageOrBlock, locale)`:

1. Load base JSON and allowlist from Tokyo.
2. If manual locale base variant exists → **skip** and log `SKIP_MANUAL_LOCALE_BASE`.
3. Compute `baseFingerprint` from base JSON.
4. If manifest already contains the same `baseFingerprint` for locale → **skip** and log `SKIP_IDEMPOTENT`.
5. Generate set-only ops constrained to the allowlist.
6. Validate ops (set-only, allowlisted, type-safe, maxChars, no structural edits).
7. Write overlay + update manifest in Tokyo.

### Prague (consumption)

For a requested page/block and locale:

1. If locale is default/unspecified → return base.
2. If manual locale base variant exists → return it.
3. Else:
   - load base
   - compute `baseFingerprint`
   - load manifest
   - if locale missing → return base
   - if `manifest.locales[locale].baseFingerprint !== baseFingerprint` → return base
   - else load overlay ops and apply (set-only) → return localized doc

**Fail-safe:** any overlay/manifest read/parse/apply failure renders base.

### CI (triggering)

Because Prague content is repo-defined, triggers are file-change driven.

Trigger on changes to:
- `tokyo/widgets/*/pages/*.json`
- `tokyo/widgets/*/pages/localization.json`
- `tokyo/widgets/*/blocks/*.json`
- `tokyo/widgets/*/blocks/localization.json`

Fan out jobs to SF for:
- all supported locales in `config/locales.json` except the base authoring locale (usually `en`)
- excluding locales that have manual locale base variants

CI does not commit overlays back to git.

### Tooling (shared determinism)

A single shared implementation must exist:

- Workspace package `tooling/l10n`
  - `package.json#name`: `@clickeen/l10n`
  - exports: `computeBaseFingerprint(value)` and deterministic canonicalization

Consumers:
- Prague: `import { computeBaseFingerprint } from '@clickeen/l10n';`
- San Francisco: `import { computeBaseFingerprint } from '@clickeen/l10n';`

---

## Allowlists (Widget-Owned, Files-as-Truth)

### Pages allowlist

- `tokyo/widgets/{widget}/pages/localization.json`

Example (shape only):
```json
{
  "v": 1,
  "pages": {
    "overview": {
      "paths": [
        { "path": "blocks[*].copy.headline", "type": "string", "maxChars": 100 },
        { "path": "blocks[*].copy.subheadline", "type": "string", "maxChars": 200 },
        {
          "path": "blocks[*].copy.items",
          "type": "array.object",
          "fields": [
            { "path": "title", "type": "string", "maxChars": 60 },
            { "path": "body", "type": "string", "maxChars": 300 }
          ]
        }
      ]
    }
  }
}
```

### Blocks allowlist

- `tokyo/widgets/{widget}/blocks/localization.json`

Same semantics as pages.

### Validator (repo hygiene)

Validator must reject:
- allowlist paths that don’t exist in base JSON
- invalid path syntax
- type mismatches
- prohibited/structural fields

---

## Minimal Data Formats

### Manifest

`tokyo/l10n/pages/{widget}/{page}/manifest.json`
```json
{
  "v": 1,
  "locales": {
    "es": { "file": "es.<baseFingerprint>.ops.json", "baseFingerprint": "..." }
  }
}
```

### Overlay

`tokyo/l10n/pages/{widget}/{page}/{locale}.{baseFingerprint}.ops.json`
```json
{
  "v": 1,
  "baseFingerprint": "...",
  "ops": [
    { "op": "set", "path": "blocks[0].copy.headline", "value": "..." }
  ]
}
```

---

## Observability

SF logs per job:
- `kind`: `pages|blocks`
- `widget`, `page|block`, `locale`
- `baseFingerprint`
- `opsCount`
- `allowlistVersion`
- `skippedReason`: `SKIP_MANUAL_LOCALE_BASE | SKIP_IDEMPOTENT | null`

Prague logs only for:
- stale overlay (fingerprint mismatch)
- overlay load/parse/apply failure (then renders base)

---

## Rollout (Small → Wide)

1. One widget, one page end-to-end.
2. Same widget, all required pages.
3. Second widget.
4. Add blocks (if Prague renders them as separate artifacts).

---

## Implementation Checklist (Short)

1. Add allowlists + validator.
2. Add `tooling/l10n` (`@clickeen/l10n`) and use it everywhere.
3. Add SF targets: `l10n.pages.v1`, `l10n.blocks.v1`.
4. Add Tokyo writer for manifests/overlays under `tokyo/l10n/{pages|blocks}/...`.
5. Update Prague loader(s) to apply precedence + overlay.
6. Add CI workflow to detect changed pages/blocks and fan out.

---

## Alignment Note (Instances vs Prague)

Instances are complicated because of *ownership, entitlements, and DB lifecycle*. Prague pages/blocks are easy because they are **owned files**.

But the overlay contract is identical across systems:
- set-only ops
- allowlist constrained
- deterministic staleness via `baseFingerprint`
- observability metadata
