# How We Build Widgets

> **Purpose**: AI-first implementation playbook for building a widget definition in `tokyo/widgets/{widgetname}/`.
>
> For system architecture and data flow, see [WidgetArchitecture.md](./WidgetArchitecture.md).

---

## AI Build Playbook

### Globals (platform-provided, never reinvent)

These exist for **every** widget and should be treated as fixed infrastructure:

- **Stage/Pod** (container + placement)
  - State: `state.stage.*` and `state.pod.*`
  - Runtime: `window.CKStagePod.applyStagePod(state.stage, state.pod, widgetRoot)`
  - Editor UI:
    - **Stage/Pod Layout** (auto-generated in Layout when `defaults.stage` / `defaults.pod` exist)
    - **Stage/Pod Appearance** (authored in Appearance via `tooldrawer-field-podstageappearance`)
- **Typography** (text roles → CSS variables)
  - Runtime: `window.CKTypography.applyTypography(state.typography, el, roleMap)`
  - Editor UI: auto-generated Typography panel when `defaults.typography.roles` exists
- **Branding** (backlink)
  - Runtime: `window.CKBranding.applyBranding(state.behavior, widgetRoot)`
- **Preview protocol** (Bob → iframe)
  - Message: `{ type: 'ck:state-update', widgetname, state }`

Widgets should not create alternative systems for these “globals”. They are the shared wheel.

### 0) Stage/Pod block (canonical, never changes)

Stage/Pod is the **shared outer layout wrapper** used by every widget. It is the stable boundary between:
- **Platform layout** (stage + pod: padding, width, alignment, radius, backgrounds)
- **Widget content** (everything inside the widget root)

Because it’s shared infrastructure (and wired into Bob’s auto-generated panels + shared runtime), the Stage/Pod block is **identical across widgets**. Widgets differ only inside the widget root.

#### What Stage/Pod does

- **Stage** is the full-width outer container. It owns:
  - background fill
  - alignment/positioning of the pod within the stage
  - stage padding
- **Pod** is the content container that “holds the widget”. It owns:
  - widget background fill (surface)
  - width mode (wrap/full/fixed) and content width
  - corner radius
  - pod padding

These values are applied by the shared runtime module:
- `tokyo/widgets/shared/stagePod.js` → `window.CKStagePod.applyStagePod(stage, pod, widgetRoot)`

#### How to use Stage/Pod (exact recipe)

**A) `spec.json` defaults must include `stage` and `pod`**

This is what drives Bob’s standard Stage/Pod panels and provides the state shape the runtime expects.

```json
{
  "stage": {
    "background": "transparent",
    "alignment": "center",
    "paddingLinked": true,
    "padding": 0,
    "paddingTop": 0,
    "paddingRight": 0,
    "paddingBottom": 0,
    "paddingLeft": 0
  },
  "pod": {
    "background": "transparent",
    "paddingLinked": true,
    "padding": 24,
    "paddingTop": 24,
    "paddingRight": 24,
    "paddingBottom": 24,
    "paddingLeft": 24,
    "widthMode": "wrap",
    "contentWidth": 960,
    "radiusLinked": true,
    "radius": "4xl",
    "radiusTL": "4xl",
    "radiusTR": "4xl",
    "radiusBR": "4xl",
    "radiusBL": "4xl"
  }
}
```

**B) `widget.html` wrapper must be exactly**

```html
<div class="stage" data-role="stage">
  <div class="pod" data-role="pod">
    <div class="ck-widget" data-ck-widget="mywidget" data-role="root">
      <!-- widget content -->

      <script src="../shared/stagePod.js" defer></script>
      <script src="./widget.client.js" defer></script>
    </div>
  </div>
</div>
```

**C) `widget.client.js` calls the shared module**

```js
window.CKStagePod.applyStagePod(state.stage, state.pod, root);
```

That’s it. Once Stage/Pod is present, the widget author focuses on everything inside the widget root.

#### Where Stage/Pod controls live in Bob (panel placement)

- **Stage/Pod layout controls** (padding, width, radius, alignment) are **auto-generated by Bob** when `defaults.stage` / `defaults.pod` exist.
  - You do **not** hand-author those controls in `spec.json`.
  - Bob injects them into the widget’s **Layout** panel as a standardized “Stage/Pod layout” group.

- **Stage/Pod fills** (backgrounds) should always live in the widget’s **Appearance** panel as a standardized “Stage/Pod appearance” group.
  - Use the special field tag `tooldrawer-field-podstageappearance` so Bob groups them correctly.

Copy/paste this cluster into your `<bob-panel id='appearance'>`:

```json
"  <tooldrawer-cluster>",
"    <tooldrawer-eyebrow text='Stage/Pod appearance' />",
"    <tooldrawer-field-podstageappearance type='dropdown-fill' size='md' path='stage.background' label='Stage background' value='{{stage.background}}' />",
"    <tooldrawer-field-podstageappearance type='dropdown-fill' size='md' path='pod.background' label='Pod background' value='{{pod.background}}' />",
"  </tooldrawer-cluster>",
```

#### Pod is the widget container (mental model + DOM map)

The Pod is literally the DOM parent container of the widget root:

```text
stage (outer page section)         ← state.stage.*
  pod (container holding widget)   ← state.pod.*
    [data-ck-widget="..."]         ← widget-specific DOM + styling
```

If you remember one thing: **pod.background is the widget’s surface**; stage.background is the outer section behind it.

#### Stage/Pod layout is not “extra” — it’s part of the main layout

Agents skip Stage/Pod layout because it’s **auto-generated** (not written in the widget’s `spec.json`), so it’s “out of sight” while authoring controls.

Treat Stage/Pod layout as the **first part of layout** for every widget:

- **Stage padding** = whitespace around the widget section (outside the pod)
- **Pod width** = how wide the widget container is (wrap / full / fixed)
- **Pod padding** = whitespace inside the widget container (around widget content)
- **Pod radius** = the widget container’s corner radius
- **Pod alignment** = where the pod sits inside the stage

If the user request is about spacing or container shape, it is almost always Stage/Pod:

- “More breathing room around the widget” → increase **stage.padding**
- “More space inside the widget card” → increase **pod.padding**
- “Make it narrower / max width” → set **pod.widthMode** + **pod.contentWidth**
- “Make corners rounder” → set **pod.radius**

For every new widget design (or new template), explicitly decide these 4 values:

- `stage.padding`
- `pod.widthMode` + (if fixed) `pod.contentWidth`
- `pod.padding`
- `pod.radius`

---

### 1) Platform contracts (standard)

- **Widget definition = 5 files in Tokyo**: `tokyo/widgets/{widgetname}/{spec.json, widget.html, widget.css, widget.client.js, agent.md}`
- **Orchestrators are dumb pipes**: Bob/Paris/Venice pass data through unchanged.
- **State shape is defined by `spec.json` + the widget runtime**: keep paths consistent across `spec.json`, `agent.md`, `widget.html`, `widget.css`, and `widget.client.js`.
- **Security + safety**:
  - Runtime behavior is implemented as deterministic DOM/CSS updates.
  - Any rich text/HTML controls are applied via a small allowlist sanitizer before `innerHTML`.
- **Deterministic runtime**: on `ck:state-update`, apply state to DOM, CSS variables, and data attributes (no network work).

### 2) Core widget skeleton (common to all widgets)

This is the shared structure every widget must implement. Everything else is widget-specific.

#### HTML wrapper hierarchy (required)

- `.stage[data-role="stage"]` → `.pod[data-role="pod"]` → widget root `[data-ck-widget="{widgetname}"]`
- All widget DOM is inside the widget root.
- All scripts are inside the widget root.

#### Shared runtime scripts (required)

These scripts must be included (inside the widget root) in this order:
- `../shared/typography.js`
- `../shared/stagePod.js`
- `../shared/branding.js`
- `./widget.client.js`

#### Runtime boot + state update listener (required)

In `widget.client.js`:
- Resolve the widget root using `document.currentScript.closest('[data-ck-widget="{widgetname}"]')`.
- Listen for Bob preview updates via `window.addEventListener('message', ...)` and handle `{ type: 'ck:state-update', widgetname, state }`.
- Apply initial embed state from `window.CK_WIDGET.state` when present.

#### DOM hooks (required pattern)

- Use `data-role="..."` attributes for every DOM node that runtime code needs to read/write.
- Keep selectors stable and explicit (no “query by text”, no brittle DOM traversal).

#### Styling contract (required pattern)

- Styling is CSS-first: `widget.client.js` sets CSS variables and data attributes, `widget.css` renders variants.
- Use widget root `data-*` attributes for major variants (layout mode, theme preset, etc.).

---

### 2.1) Main widget variants (only two): Type and Layout

In Clickeen, the only **top-level** variants that matter are:

- **Type (aka mode)**: what the widget *is* (different behavior + often different DOM block).
- **Layout**: where/how the widget is placed and arranged (bars, floating, inline, grid vs carousel, etc.).

Everything else is just normal control wiring.

#### Where Type and Layout belong (panel rule)

- **Type lives in the Content panel** because Type determines *what content exists* (which content blocks/fields are relevant).
  - Example: a widget `timer.mode` changes the content model: date vs personal vs number.
- **Layout lives in the Layout panel** because Layout determines *how the chosen type is arranged/placed*.
  - Example: inline vs top-bar vs floating.

Keep this simple rule in mind:

```text
Pod contains the widget.
Type selects the content model.
Layout selects the arrangement/placement of that type.
```

#### Type = a miniwidget spec (why this is true)

When you add a new **Type** (mode) to a widget, you are effectively adding a second **miniwidget** inside the same widget root, because a Type must include the full stack:

- **State shape**: new paths in `spec.json.defaults` (what exists in the state)
- **ToolDrawer**: controls for those paths (and `show-if` so only the active Type’s controls show)
- **Runtime**: logic that interprets those paths (what the widget does)
- **DOM/CSS**: elements and styling that can actually change in response

You can tell something is a **Type** (not “just another control”) when it changes the widget across these dimensions:

- **Primary user experience**: what the widget feels like (e.g. grid vs masonry wall vs interactive carousel)
- **Runtime behavior**: different event/timer/interaction logic (e.g. carousel navigation/drag/autoplay vs none)
- **DOM/CSS structure**: different DOM block(s) must exist or different CSS layout systems apply
- **Relevant controls**: the control set changes materially (e.g. grid columns vs carousel itemsVisible/autoplay vs masonry columns)

That’s why “adding a Type” must always answer three questions:

- **A) What is different?** (behavior + visible output)
- **B) What controls exist for this type?** (complete set of paths)
- **C) How is each control bound?** (CSS var / data-* / DOM update)

Practically: treat each Type as a **mini-spec** with its own Binding Map rows. If you can’t write the Binding Map for the new Type, the controls will almost always do nothing.

#### Why “Type” is often 50% container (Stage/Pod + Layout) — Feed vs Badge

Feed vs Badge is the quintessential example:

- **Feed** “type” feels like a *section/module* because its **container defaults** are large and deliberate:
  - Stage padding creates whitespace around the module.
  - Pod width/padding/radius creates a card-like container that holds a complex internal layout (grid/carousel/slider).
- **Badge** “type” feels like a *chip/anchor element* because its **container defaults** are tight and positional:
  - Pod is small and constrained.
  - Layout is often floating/corner-pinned (or otherwise compact).

Same idea, stated as the authoring rule:

```text
Defining a Type always includes:
1) the content model + runtime behavior inside the pod, and
2) the Stage/Pod + Layout defaults that make it feel like that type.
```

#### A) Type variant (Mode) — example: Timer widget

**State**:
- `timer.mode = 'date' | 'personal' | 'number'`

**ToolDrawer**:
- One dropdown chooses the type.
- Type-specific controls are wrapped in `show-if` clusters.

Example (from the pattern):

```json
"  <tooldrawer-field type='dropdown-actions' size='lg' path='timer.mode' label='Timer mode' value='{{timer.mode}}' options='[{\"label\":\"Target date\",\"value\":\"date\"},{\"label\":\"Personal timer\",\"value\":\"personal\"},{\"label\":\"Number counter\",\"value\":\"number\"}]' />",
"  <tooldrawer-cluster show-if=\"timer.mode == 'date'\">",
"    <tooldrawer-field type='textfield' size='lg' path='timer.dateTarget.targetDate' label='Target Date' />",
"  </tooldrawer-cluster>",
"  <tooldrawer-cluster show-if=\"timer.mode == 'number'\">",
"    <tooldrawer-field type='textfield' size='md' path='timer.numberCounter.targetNumber' label='Target number' />",
"  </tooldrawer-cluster>",
```

**Runtime** (`widget.client.js`):
- Set a single attribute on the widget root:
  - `root.setAttribute('data-mode', state.timer.mode)`
- Show exactly one DOM block at a time (example):
  - `[data-role="units"]` for timer units
  - `[data-role="number"]` for number mode

#### B) Layout variant — example: “where the widget lives”

**State**:
- `layout.type = 'inline' | 'full-width' | 'top-bar' | 'bottom-bar' | 'floating'`
- `layout.alignment = 'left' | 'center' | 'right'`

**ToolDrawer**:
- A “Layout” dropdown + alignment segmented control.
- Layout-specific controls live under `show-if="layout.type == 'floating'"`, etc.

**Runtime + CSS**:
- `root.setAttribute('data-layout', state.layout.type)`
- `root.setAttribute('data-alignment', state.layout.alignment)`
- CSS selects variants:
  - `.ck-widget[data-layout='top-bar'] { position: fixed; top: 0; left: 0; right: 0; }`
  - `.ck-widget[data-layout='floating'][data-corner='bottom-right'] { ... }`

If you can’t describe a widget change as either **Type** or **Layout**, it’s not a top-level variant—treat it as a normal control binding (CSS var / data attr / DOM update).

#### C) “One type, multiple layouts” — example: FAQ

FAQ has **one type** (it is always an FAQ), and the main variant axis is **Layout**:
- `layout.type = 'accordion' | 'list' | 'multicolumn'`

The pattern is:
- ToolDrawer selects layout type.
- Layout-specific controls use `show-if` (accordion behaviors only when `layout.type == 'accordion'`; columns only when `layout.type == 'multicolumn'`).
- Runtime sets `data-layout` on the widget root, and CSS renders the layout.

Concrete example (from `tokyo/widgets/faq/spec.json`):

```json
"<tooldrawer-field type='choice-tiles' size='md' path='layout.type' label='Layout' value='{{layout.type}}' options='[...]' />",
"<tooldrawer-field type='toggle' size='md' path='behavior.expandFirst' label='Open first question by default' show-if=\"layout.type == 'accordion'\" />",
"<tooldrawer-cluster show-if=\"layout.type == 'multicolumn'\">",
"  <tooldrawer-field type='textfield' size='md' path='layout.columns.desktop' label='Columns (desktop)' />",
"</tooldrawer-cluster>",
```

Concrete runtime binding (from `tokyo/widgets/faq/widget.client.js`):
- `faqRoot.setAttribute('data-layout', layout.type)`

---

### 3) ToolDrawer → Widget binding (the rule that prevents “dead controls”)

Every ToolDrawer control must be connected to the actual widget via an explicit binding. In Clickeen, a control is “real” only when:

- **A. Path exists in defaults**: the control’s `path="..."` must exist under `spec.json.defaults` so the state shape is real.
- **B. Widget has a target**: there is a concrete DOM node to change (via `data-role="..."`) or a variant to toggle (via `data-*` on the widget root).
- **C. Runtime applies it**: `widget.client.js` applies the state value to one of the supported mechanisms below, and `widget.css`/DOM reflects it.

#### Supported binding mechanisms (pick one per control)

- **CSS variable**: `widget.client.js` sets a CSS variable → `widget.css` uses it.
- **Data attribute**: `widget.client.js` sets `data-*` on the widget root → `widget.css` uses selectors like `[data-layout="..."]`.
- **DOM update**: `widget.client.js` sets text / html / visibility on a specific `[data-role="..."]` element.

#### Required “Binding Map” (write this before adding controls)

For every control you add to `spec.json`, add a row to this map (in your widget’s `agent.md` or at the top of `widget.client.js` as comments):

| ToolDrawer path | Target | Mechanism | Implementation |
|---|---|---|---|
| `content.title` | `[data-role="heading"]` | DOM text | `heading.textContent = state.content.title` |
| `appearance.headingColor` | widget root | CSS var | `root.style.setProperty('--heading-color', state.appearance.headingColor)` |
| `layout.mode` | widget root | data attr | `root.setAttribute('data-layout', state.layout.mode)` |

If a control cannot be described in this table, it will almost always “do nothing” in the widget.

#### Minimal implementation checklist (per new control)

- **1. `spec.json`**: add the default value at the path + add the ToolDrawer field with the same `path`.
- **2. `widget.html`**: add/confirm the target element exists with the `data-role` used by runtime.
- **3. `widget.client.js`**: apply the state value using exactly one mechanism above.
- **4. `widget.css`** (only if needed): add CSS that uses the CSS var or data attribute.
- **5. Verification**: change the control in Bob and confirm the DOM/CSS changes in the preview.

### 3) Optional: reference widget

If you want a concrete example that follows the core skeleton cleanly, use:
- `tokyo/widgets/faq/`

### 4) Build in this order

1. **`spec.json` defaults** (state shape and defaults)
2. **`widget.html` roles** (DOM skeleton with `data-role` hooks)
3. **`widget.css`** (CSS variables + variants by data attributes)
4. **`widget.client.js`** (applyState: set vars/attrs + update DOM + hook shared modules)
5. **`spec.json` ToolDrawer controls** (every control must map to runtime behavior)
6. **`agent.md`** (editable paths + selector map + enums)

---

## Copy/Paste Templates (5 files)

These are intentionally minimal and correct. Start here and extend.

### `widget.html` template (structure + script placement)

Key rule: **scripts must be inside** the `[data-ck-widget="..."]` element so `document.currentScript.closest(...)` works.

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MyWidget</title>
    <link rel="stylesheet" href="/dieter/tokens/tokens.css" />
    <link rel="stylesheet" href="./widget.css" />
  </head>
  <body>
    <div class="stage" data-role="stage">
      <div class="pod" data-role="pod">
        <div class="ck-widget" data-ck-widget="mywidget" data-role="root">
          <!-- content -->
          <h2 data-role="heading">Title</h2>
          <div data-role="content"></div>

          <!-- shared runtime -->
          <script src="../shared/typography.js" defer></script>
          <script src="../shared/stagePod.js" defer></script>
          <script src="../shared/branding.js" defer></script>
          <script src="./widget.client.js" defer></script>
        </div>
      </div>
    </div>
  </body>
</html>
```

### `widget.client.js` template (strict + deterministic)

```js
(function () {
  if (typeof window === 'undefined' || typeof document === 'undefined') return;

  const scriptEl = document.currentScript;
  if (!(scriptEl instanceof HTMLElement)) return;

  const root = scriptEl.closest('[data-ck-widget="mywidget"]');
  if (!(root instanceof HTMLElement)) {
    throw new Error('[MyWidget] widget.client.js must be inside [data-ck-widget="mywidget"]');
  }

  function applyState(state) {
    if (!state || typeof state !== 'object') return;

    window.CKTypography.applyTypography(state.typography, root, {
      heading: { varKey: 'heading' },
      body: { varKey: 'body' },
    });
    window.CKStagePod.applyStagePod(state.stage, state.pod, root);
    window.CKBranding.applyBranding(state.behavior, root);

    // Example: CSS variables
    root.style.setProperty('--heading-color', state.appearance.headingColor);

    // Example: DOM updates
    const heading = root.querySelector('[data-role="heading"]');
    if (heading instanceof HTMLElement) heading.textContent = state.content.title;
  }

  window.addEventListener('message', (event) => {
    const msg = event.data;
    if (!msg || msg.type !== 'ck:state-update') return;
    if (msg.widgetname && msg.widgetname !== 'mywidget') return;
    applyState(msg.state);
  });

  const initialState = window.CK_WIDGET && window.CK_WIDGET.state;
  if (initialState) applyState(initialState);
})();
```

### `spec.json` template (defaults + ToolDrawer)

Notes for agents:
- `html` is a JSON array of **strings**: keep escaping correct.
- `options='[...]'` is **JSON inside a string**: keep it minified and valid JSON.
- Prefer double quotes in `show-if` attributes so inner single quotes are easy: `show-if="layout.mode == 'grid'"`.

```json
{
  "widgetname": "mywidget",
  "defaults": {
    "content": { "title": "Hello" },
    "layout": { "mode": "default" },
    "appearance": { "headingColor": "var(--color-system-black)" },
    "settings": {},
    "stage": { "background": "transparent", "alignment": "center", "paddingLinked": true, "padding": 0 },
    "pod": { "background": "transparent", "paddingLinked": true, "padding": 24, "widthMode": "wrap", "contentWidth": 960, "radiusLinked": true, "radius": "4xl" },
    "typography": { "globalFamily": "Inter", "roleScales": {}, "roles": {} },
    "behavior": { "showBacklink": true }
  },
  "html": [
    "<bob-panel id='content'>",
    "  <tooldrawer-cluster>",
    "    <tooldrawer-field type='textfield' size='lg' path='content.title' label='Title' value='{{content.title}}' />",
    "  </tooldrawer-cluster>",
    "</bob-panel>",
    "",
    "<bob-panel id='appearance'>",
    "  <tooldrawer-cluster>",
    "    <tooldrawer-field type='dropdown-fill' size='md' path='appearance.headingColor' label='Heading color' />",
    "  </tooldrawer-cluster>",
    "</bob-panel>"
  ]
}
```

### `agent.md` template (AI editing contract)

```md
# MyWidget Agent Context

## Editable Paths
- `content.title` (string)
- `appearance.headingColor` (color)
- `behavior.showBacklink` (boolean)

## Parts Map
| Role | Selector | Editable |
|------|----------|----------|
| heading | [data-role="heading"] | content.title |

## Enums
- (list any enums here)
```

---

## Verification Checklist (use before shipping)

Minimal checks in Bob:
- Toggle a dropdown that switches a data attribute (`layout.type`, `timer.mode`) and confirm the widget root updates (`data-layout`, `data-mode`, etc.).
- Change a color control and confirm the corresponding CSS variable updates on the widget root.
- Change a text control and confirm the DOM updates immediately.

If a change isn’t reflected:
- Confirm the preview iframe is loading the latest widget assets (cache-busted URL in Bob, `Cache-Control: no-store` in Tokyo dev).
- Confirm `widget.client.js` is running (no console errors) and its listener receives `ck:state-update`.
- Confirm `data-role` selectors in `widget.html` match the queries in `widget.client.js`.

## ToolDrawer Field Types

| Type | Use For |
|------|---------|
| `textfield` | Short text input |
| `textedit` | Long text with formatting |
| `toggle` | Boolean on/off |
| `slider` | Numeric range |
| `dropdown-actions` | Select from options |
| `dropdown-fill` | Color/fill picker |
| `segmented` | 2-4 mutually exclusive options |
| `repeater` | Array of items |

---

## Shared Runtime Modules

Located in `tokyo/widgets/shared/`:

| Module | Purpose |
|--------|---------|
| `typography.js` | Applies font settings from `state.typography` |
| `stagePod.js` | Applies stage/pod settings |
| `branding.js` | Handles "Made with Clickeen" badge |

Usage in widget.client.js:
```javascript
window.CKTypography.applyTypography(state.typography, widgetRoot, roleMap);
window.CKStagePod.applyStagePod(state.stage, state.pod, widgetRoot);
```
