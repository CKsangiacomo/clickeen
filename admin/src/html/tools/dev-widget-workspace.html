<!--
  ═══════════════════════════════════════════════════════════════════════════
  Widget Development Workspace (DevStudio Tools Page)
  ═══════════════════════════════════════════════════════════════════════════

  PURPOSE:
  This DevStudio page provides a workspace for developing and testing widgets
  with full integration across all Clickeen services.

  WHAT IT DOES:
  - Embeds Bob widget builder (remote by default; configurable via ?bob=...)
  - Instance switcher to test different widget instances
  - Full integration: Bob + Paris API + Venice SSR preview

  ARCHITECTURE:
  - Bob service code: /bob directory (Next.js app)
  - Paris service code: /paris directory (API)
  - Venice service code: /venice directory (SSR)
  - This file: DevStudio page that INTEGRATES those services

  AI NOTE:
  This is NOT Bob itself - it's a DevStudio page that embeds Bob in an iframe.
  To modify Bob's actual functionality, edit files in /bob directory.
  ═══════════════════════════════════════════════════════════════════════════
-->
<div
  class="devstudio-page"
  style="
    display: flex;
    flex-direction: column;
    height: 100%;
    padding: 0;
    background: var(--color-system-white);
  "
>
  <style>
    .docs-shell__main.devstudio-page-layout {
      padding: 32px;
    }

    .dev-widget-workspace-header {
      display: flex;
      align-items: center;
      gap: var(--space-4);
      margin: 0 0 var(--space-4) 0;
      width: 100%;
    }

    .dev-widget-workspace-header > * {
      margin: 0;
    }

    #privileged-actions {
      display: none;
      align-items: center;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    #privileged-actions .diet-btn-txt {
      box-shadow: var(--shadow-floating);
    }

    #privileged-actions .dev-widget-workspace__actions {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    #privileged-actions .dev-widget-workspace__actions-group {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    #privileged-actions .dev-widget-workspace__actions-divider {
      inline-size: 1px;
      block-size: 20px;
      background: color-mix(in oklab, var(--role-border), transparent 35%);
      border-radius: 999px;
    }

    #privileged-actions .dev-widget-workspace__action,
    .dev-widget-workspace__modal .dev-widget-workspace__action {
      --btn-border-width: 0px;
      --btn-border-color: transparent;
      --btn-bg: var(--action-bg);
      --btn-color: var(--color-system-black);
      --btn-icon-color: var(--color-system-black);
      --btn-hover-bg: color-mix(in oklab, var(--action-bg), var(--color-system-black) 8%);
      --btn-hover-border-color: transparent;
      --btn-clicked-bg: color-mix(in oklab, var(--action-bg), var(--color-system-black) 14%);
      --btn-clicked-border-color: transparent;
      box-shadow: var(--shadow-floating);
    }

    #privileged-actions .dev-widget-workspace__action[data-tone='green4'],
    .dev-widget-workspace__modal .dev-widget-workspace__action[data-tone='green4'] {
      --action-bg: var(--color-system-green-4);
    }

    #privileged-actions .dev-widget-workspace__action[data-tone='purple4'],
    .dev-widget-workspace__modal .dev-widget-workspace__action[data-tone='purple4'] {
      --action-bg: var(--color-system-purple-4);
    }

    #privileged-actions .dev-widget-workspace__action[data-tone='pink4'],
    .dev-widget-workspace__modal .dev-widget-workspace__action[data-tone='pink4'] {
      --action-bg: var(--color-system-pink-4);
    }

    #privileged-actions .dev-widget-workspace__action[data-tone='indigo4'],
    .dev-widget-workspace__modal .dev-widget-workspace__action[data-tone='indigo4'] {
      --action-bg: var(--color-system-indigo-4);
    }

    #privileged-actions .dev-widget-workspace__action[data-tone='brown.5'],
    .dev-widget-workspace__modal .dev-widget-workspace__action[data-tone='brown.5'] {
      --action-bg: var(--color-system-brown-5);
    }

    #privileged-actions .dev-widget-workspace__action[data-tone='gray4.4'],
    .dev-widget-workspace__modal .dev-widget-workspace__action[data-tone='gray4.4'] {
      --action-bg: color-mix(in oklab, var(--color-system-gray-4), white 80%);
    }

    #privileged-actions .dev-widget-workspace__action[data-tone='teal.5'],
    .dev-widget-workspace__modal .dev-widget-workspace__action[data-tone='teal.5'] {
      --action-bg: color-mix(in oklab, var(--color-system-teal), white 90%);
    }

    #l10n-status {
      display: none;
      align-items: center;
      gap: var(--space-2);
      padding: 6px 10px;
      margin-left: auto;
      margin-right: var(--space-2);
      border-radius: var(--control-radius-lg);
      border: 1px solid color-mix(in oklab, var(--role-border), transparent 25%);
      background: color-mix(in oklab, var(--color-system-gray-4), white 90%);
      box-shadow: var(--shadow-floating);
      font: 500 var(--fs-12) / var(--lh-tight) var(--font-ui);
      color: var(--color-text);
      position: relative;
    }

    #l10n-status[data-state='hidden'] {
      display: none;
    }

    .dev-widget-workspace__l10n-label {
      color: color-mix(in oklab, var(--color-text), transparent 25%);
      font-size: var(--fs-12);
    }

    .dev-widget-workspace__l10n-dot {
      inline-size: 8px;
      block-size: 8px;
      border-radius: 999px;
      background: var(--color-system-gray-6);
    }

    #l10n-status[data-tone='ready'] .dev-widget-workspace__l10n-dot {
      background: var(--color-system-green);
    }

    #l10n-status[data-tone='pending'] .dev-widget-workspace__l10n-dot,
    #l10n-status[data-tone='refreshing'] .dev-widget-workspace__l10n-dot {
      background: var(--color-system-yellow);
    }

    #l10n-status[data-tone='running'] .dev-widget-workspace__l10n-dot {
      background: var(--color-system-blue);
    }

    #l10n-status[data-tone='retrying'] .dev-widget-workspace__l10n-dot {
      background: var(--color-system-orange);
    }

    #l10n-status[data-tone='unavailable'] .dev-widget-workspace__l10n-dot {
      background: var(--color-system-gray-7);
    }

    .dev-widget-workspace__l10n-value,
    .dev-widget-workspace__l10n-meta {
      display: none;
    }

    .dev-widget-workspace__l10n-tooltip {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      z-index: 40;
      max-inline-size: min(560px, 72vw);
      padding: 8px 10px;
      border-radius: var(--control-radius-md);
      border: 1px solid color-mix(in oklab, var(--role-border), transparent 15%);
      background: var(--color-system-gray-8, #1f2328);
      background: color-mix(in oklab, var(--color-system-black), var(--color-system-white) 8%);
      box-shadow: var(--shadow-floating);
      color: var(--color-system-white);
      font: 500 var(--fs-11) / 1.4 var(--font-ui);
      letter-spacing: 0.01em;
      white-space: normal;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transform: translateY(2px);
      transition:
        opacity var(--duration-base),
        transform var(--duration-base),
        visibility var(--duration-base);
    }

    #l10n-status:hover .dev-widget-workspace__l10n-tooltip,
    #l10n-status:focus-visible .dev-widget-workspace__l10n-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .dev-widget-workspace-header #instance-dropdown {
      min-inline-size: 240px;
    }

    .dev-widget-workspace-header #widget-selector {
      flex: 0 0 160px;
      inline-size: 160px;
      min-inline-size: 160px;
      max-inline-size: 160px;
    }

    .dev-widget-workspace-header #widget-selector .diet-textfield__control {
      box-shadow: var(--shadow-floating);
    }

    .dev-widget-workspace-header .diet-dropdown {
      position: relative;
    }

    .dev-widget-workspace-header .diet-dropdown__control {
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--control-inline-gap-md);
      inline-size: 100%;
      min-block-size: var(--control-size-lg);
      padding-inline: var(--control-padding-inline);
      border-radius: var(--control-radius-lg);
      border: 1px solid color-mix(in oklab, var(--role-border), transparent 10%);
      background: var(--role-surface-bg);
      box-shadow: var(--shadow-floating);
      color: var(--color-text);
      cursor: pointer;
      transition:
        background-color var(--duration-base),
        box-shadow var(--duration-base);
    }

    .dev-widget-workspace-header .diet-dropdown__control:hover {
      background: color-mix(in oklab, var(--role-surface-bg), var(--color-system-white) 6%);
      box-shadow: var(--shadow-floating);
    }

    .dev-widget-workspace-header .diet-dropdown__control:focus-visible {
      outline: 2px solid var(--focus-ring-color, var(--color-system-blue));
      outline-offset: 2px;
    }

    .dev-widget-workspace-header .diet-dropdown__value {
      display: inline-flex;
      align-items: baseline;
      gap: var(--space-0);
      min-inline-size: 0;
    }

    .dev-widget-workspace-header .diet-dropdown__value-label {
      color: color-mix(in oklab, var(--color-text), transparent 40%);
      font: 500 var(--fs-12) / var(--lh-tight) var(--font-ui);
    }

    .dev-widget-workspace-header .diet-dropdown__value-choice {
      font: 600 var(--fs-14) / var(--lh-tight) var(--font-ui);
      letter-spacing: -0.01em;
    }

    .dev-widget-workspace-header .diet-dropdown__icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: color-mix(in oklab, var(--color-text), transparent 40%);
    }

    .dev-widget-workspace-header .diet-dropdown__icon svg {
      inline-size: var(--icon-size-16);
      block-size: var(--icon-size-16);
      transition: transform var(--duration-base);
    }

    .dev-widget-workspace-header .diet-dropdown[data-state='open'] .diet-dropdown__icon svg {
      transform: rotate(180deg);
    }

    .dev-widget-workspace-header .diet-popover {
      display: none;
      position: absolute;
      inset-inline-start: 0;
      inset-block-start: calc(100% + var(--space-2));
      inline-size: 100%;
      z-index: 10;
      padding: var(--space-3);
      border-radius: var(--radius-4);
      border: 1px solid color-mix(in oklab, var(--role-border), transparent 25%);
      background: var(--color-system-white);
      box-shadow: var(--shadow-floating-lg);
    }

    .dev-widget-workspace-header .diet-dropdown[data-state='open'] .diet-popover {
      display: block;
    }

    .dev-widget-workspace-header .diet-dropdown__options {
      display: grid;
      gap: var(--space-1);
    }

    .dev-widget-workspace-header .diet-dropdown__option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      inline-size: 100%;
      border-radius: var(--control-radius-md);
      padding-inline: var(--control-padding-inline);
      min-block-size: var(--control-size-md);
      transition: background-color var(--duration-base);
    }

    .dev-widget-workspace-header .diet-dropdown__option svg {
      inline-size: 1rem;
      block-size: 1rem;
    }

    .dev-widget-workspace-header
      .diet-dropdown__option:not(.is-selected)
      .diet-btn-menuactions__icon {
      opacity: 0;
    }

    .dev-widget-workspace-header .diet-dropdown__option:hover {
      background: color-mix(in oklab, var(--role-surface-bg), var(--color-system-white) 12%);
    }

    .dev-widget-workspace-header .diet-dropdown__option.is-selected {
      background: color-mix(in oklab, var(--color-system-blue), transparent 88%);
      color: var(--color-system-blue);
    }

    .dev-widget-workspace-header .dev-widget-workspace__empty-option {
      border-radius: var(--control-radius-md);
      padding: var(--space-2) var(--space-3);
      color: color-mix(in oklab, var(--color-text), transparent 35%);
      background: color-mix(in oklab, var(--role-surface-bg), var(--color-system-white) 12%);
    }

    .dev-widget-workspace__modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: var(--space-4);
      background: color-mix(in oklab, var(--color-system-black), transparent 65%);
      z-index: 50;
    }

    .dev-widget-workspace__modal[hidden] {
      display: none;
    }

    .dev-widget-workspace__modal-body {
      inline-size: min(720px, 100%);
      max-block-size: min(80vh, 720px);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
      padding: var(--space-4);
      border-radius: var(--radius-4);
      border: 1px solid color-mix(in oklab, var(--role-border), transparent 25%);
      background: var(--color-system-white);
      box-shadow: var(--shadow-floating-lg);
    }

    .dev-widget-workspace__modal-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: var(--space-3);
    }

    .dev-widget-workspace__modal-title {
      font: 600 var(--fs-16) / var(--lh-tight) var(--font-ui);
      letter-spacing: -0.01em;
    }

    .dev-widget-workspace__modal-subtitle {
      font: 500 var(--fs-12) / var(--lh-tight) var(--font-ui);
      color: color-mix(in oklab, var(--color-text), transparent 40%);
    }

    .dev-widget-workspace__modal-content {
      overflow: auto;
      display: grid;
      gap: var(--space-4);
    }

    .dev-widget-workspace__variant-grid {
      display: grid;
      gap: var(--space-3);
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .dev-widget-workspace__field-helper {
      font: 500 var(--fs-12) / var(--lh-tight) var(--font-ui);
      color: color-mix(in oklab, var(--color-text), transparent 35%);
      letter-spacing: -0.005em;
      overflow-wrap: anywhere;
    }

    .dev-widget-workspace__modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: var(--space-2);
    }
  </style>

  <header class="devstudio-page__header" style="flex-shrink: 0">
    <h1 class="heading-2" style="margin: 0">Widget Workspace</h1>
    <div id="privileged-actions">
      <div class="dev-widget-workspace__actions">
        <div class="dev-widget-workspace__actions-group" data-group="primary">
          <button
            type="button"
            class="diet-btn-ictxt dev-widget-workspace__action"
            id="privileged-update-defaults"
            data-size="md"
            data-variant="secondary"
            data-tone="brown.5"
          >
            <span
              class="diet-btn-ictxt__icon"
              aria-hidden="true"
              data-icon="arrow.trianglehead.clockwise"
            ></span>
            <span class="diet-btn-ictxt__label body-s">Update Config</span>
          </button>
          <button
            type="button"
            class="diet-btn-ictxt dev-widget-workspace__action"
            id="privileged-reset-from-json"
            data-size="md"
            data-variant="secondary"
            data-tone="brown.5"
          >
            <span
              class="diet-btn-ictxt__icon"
              aria-hidden="true"
              data-icon="square.and.arrow.down"
            ></span>
            <span class="diet-btn-ictxt__label body-s">Reset Json</span>
          </button>
          <button
            type="button"
            class="diet-btn-ictxt dev-widget-workspace__action"
            id="refresh-prague-preview"
            data-size="md"
            data-variant="secondary"
            data-tone="brown.5"
          >
            <span
              class="diet-btn-ictxt__icon"
              aria-hidden="true"
              data-icon="arrow.trianglehead.clockwise"
            ></span>
            <span class="diet-btn-ictxt__label body-s">Refresh Prague</span>
          </button>
          <button
            type="button"
            class="diet-btn-ictxt dev-widget-workspace__action"
            id="translate-selected-locales"
            data-size="md"
            data-variant="secondary"
            data-tone="brown.5"
          >
            <span class="diet-btn-ictxt__icon" aria-hidden="true" data-icon="globe"></span>
            <span class="diet-btn-ictxt__label body-s">Translate</span>
          </button>
          <button
            type="button"
            class="diet-btn-ictxt dev-widget-workspace__action"
            id="privileged-update-theme"
            data-size="md"
            data-variant="secondary"
            data-tone="brown.5"
          >
            <span
              class="diet-btn-ictxt__icon"
              aria-hidden="true"
              data-icon="paintbrush.pointed"
            ></span>
            <span class="diet-btn-ictxt__label body-s">Update Theme</span>
          </button>
        </div>
        <span class="dev-widget-workspace__actions-divider" aria-hidden="true"></span>
        <div class="dev-widget-workspace__actions-group" data-group="secondary">
          <button
            type="button"
            class="diet-btn-ictxt dev-widget-workspace__action"
            id="create-curated-instance"
            data-size="md"
            data-variant="secondary"
            data-tone="gray4.4"
          >
            <span class="diet-btn-ictxt__icon" aria-hidden="true" data-icon="plus.square"></span>
            <span class="diet-btn-ictxt__label body-s">New Curated</span>
          </button>
          <button
            type="button"
            class="diet-btn-ictxt dev-widget-workspace__action"
            id="update-curated-instance"
            data-size="md"
            data-variant="secondary"
            data-tone="gray4.4"
          >
            <span
              class="diet-btn-ictxt__icon"
              aria-hidden="true"
              data-icon="arrow.trianglehead.2.counterclockwise"
            ></span>
            <span class="diet-btn-ictxt__label body-s">Update Curated</span>
          </button>
        </div>
      </div>
    </div>
    <div
      id="l10n-status"
      role="status"
      aria-live="polite"
      data-state="idle"
      data-tone="unavailable"
      tabindex="0"
    >
      <span class="dev-widget-workspace__l10n-label">Translations</span>
      <span class="dev-widget-workspace__l10n-dot" aria-hidden="true"></span>
      <span class="dev-widget-workspace__l10n-value" id="l10n-status-value">-</span>
      <span class="dev-widget-workspace__l10n-meta" id="l10n-status-meta"></span>
      <span class="dev-widget-workspace__l10n-tooltip" id="l10n-status-tooltip"></span>
    </div>
    <div class="diet-textfield" data-size="md" id="widget-selector" style="display: none">
      <label class="diet-textfield__control">
        <select id="widget-select" class="diet-textfield__field" aria-label="Widget"></select>
      </label>
    </div>
    <div
      class="diet-dropdown"
      id="instance-dropdown"
      data-size="md"
      data-state="closed"
      style="display: none"
    >
      <div
        id="instance-dropdown-control"
        class="diet-dropdown__control"
        role="button"
        tabindex="0"
        aria-haspopup="listbox"
        aria-expanded="false"
        aria-label="Select instance"
      >
        <span class="diet-dropdown__value">
          <span class="diet-dropdown__value-choice body" id="current-instance-label"
            >Loading...</span
          >
        </span>
        <span class="diet-dropdown__icon" aria-hidden="true">
          <svg viewBox="0 0 16 16" fill="none">
            <path
              d="M4 6l4 4 4-4"
              stroke="currentColor"
              stroke-width="1.5"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
        </span>
      </div>
      <input id="instance-dropdown-value" type="hidden" value="" />
      <div class="diet-popover" role="dialog" aria-label="Select widget instance">
        <div class="diet-popover__body">
          <div class="diet-dropdown__options" role="listbox" id="instance-dropdown-menu">
            <!-- Instances will be populated here -->
          </div>
        </div>
      </div>
    </div>
  </header>

  <div
    class="devstudio-page-section"
    style="padding: 0; overflow: hidden; flex: 1; margin: 0; display: flex"
  >
    <iframe
      id="bob-iframe"
      src="about:blank"
      style="width: 100%; height: 100%; border: 0; display: block"
      title="Bob Widget Builder"
    ></iframe>
  </div>

  <div class="dev-widget-workspace__modal" id="curated-modal" hidden>
    <div
      class="dev-widget-workspace__modal-body"
      role="dialog"
      aria-modal="true"
      aria-labelledby="curated-modal-title"
    >
      <div class="dev-widget-workspace__modal-header">
        <div>
          <div class="dev-widget-workspace__modal-title" id="curated-modal-title">
            Create curated instance
          </div>
          <div class="dev-widget-workspace__modal-subtitle" id="curated-modal-subtitle"></div>
        </div>
        <button
          class="diet-btn-txt"
          type="button"
          data-size="sm"
          data-variant="neutral"
          id="curated-modal-close"
        >
          <span class="diet-btn-txt__label">Close</span>
        </button>
      </div>
      <div class="dev-widget-workspace__modal-content">
        <div class="diet-textfield" data-size="md">
          <label class="diet-textfield__control">
            <span class="diet-textfield__display-label">Instance name</span>
            <input
              id="curated-style-name"
              type="text"
              class="diet-textfield__field"
              placeholder="lightblurs"
              autocomplete="off"
            />
          </label>
        </div>
        <div class="dev-widget-workspace__variant-grid">
          <div class="diet-textfield" data-size="md">
            <label class="diet-textfield__control">
              <span class="diet-textfield__display-label">Variant (optional)</span>
              <input
                id="curated-variant-primary"
                type="text"
                class="diet-textfield__field"
                placeholder="hospitality"
                autocomplete="off"
              />
            </label>
          </div>
          <div class="diet-textfield" data-size="md">
            <label class="diet-textfield__control">
              <span class="diet-textfield__display-label">Sub-variant (optional)</span>
              <input
                id="curated-variant-secondary"
                type="text"
                class="diet-textfield__field"
                placeholder="airbnb"
                autocomplete="off"
              />
            </label>
          </div>
        </div>
        <div class="dev-widget-workspace__field-helper" id="curated-style-preview"></div>
      </div>
      <div class="dev-widget-workspace__modal-actions">
        <button
          class="diet-btn-txt"
          type="button"
          data-size="md"
          data-variant="secondary"
          id="curated-modal-cancel"
        >
          <span class="diet-btn-txt__label">Cancel</span>
        </button>
        <button
          class="diet-btn-ictxt dev-widget-workspace__action"
          type="button"
          data-size="md"
          data-variant="secondary"
          data-tone="green4"
          id="curated-modal-confirm"
        >
          <span class="diet-btn-ictxt__icon" aria-hidden="true" data-icon="plus.square"></span>
          <span class="diet-btn-ictxt__label body-s">Create curated instance</span>
        </button>
      </div>
    </div>
  </div>

  <div class="dev-widget-workspace__modal" id="theme-modal" hidden>
    <div
      class="dev-widget-workspace__modal-body"
      role="dialog"
      aria-modal="true"
      aria-labelledby="theme-modal-title"
    >
      <div class="dev-widget-workspace__modal-header">
        <div>
          <div class="dev-widget-workspace__modal-title" id="theme-modal-title">Update theme</div>
          <div class="dev-widget-workspace__modal-subtitle" id="theme-modal-subtitle">
            Overwrite a Tokyo theme with the current editor state.
          </div>
        </div>
        <button
          class="diet-btn-txt"
          type="button"
          data-size="sm"
          data-variant="neutral"
          id="theme-modal-close"
        >
          <span class="diet-btn-txt__label">Close</span>
        </button>
      </div>
      <div class="dev-widget-workspace__modal-content">
        <div class="diet-textfield" data-size="md">
          <label class="diet-textfield__control">
            <span class="diet-textfield__display-label">Theme</span>
            <select id="theme-modal-select" class="diet-textfield__field"></select>
          </label>
        </div>
      </div>
      <div class="dev-widget-workspace__modal-actions">
        <button
          class="diet-btn-txt"
          type="button"
          data-size="md"
          data-variant="secondary"
          id="theme-modal-cancel"
        >
          <span class="diet-btn-txt__label">Cancel</span>
        </button>
        <button
          class="diet-btn-ictxt dev-widget-workspace__action"
          type="button"
          data-size="md"
          data-variant="secondary"
          data-tone="orange4"
          id="theme-modal-confirm"
        >
          <span
            class="diet-btn-ictxt__icon"
            aria-hidden="true"
            data-icon="paintbrush.pointed"
          ></span>
          <span class="diet-btn-ictxt__label body-s">Update theme</span>
        </button>
      </div>
    </div>
  </div>

  <script type="module">
    const OPEN_EDITOR_CONTRACT_PATH = '/tooling/contracts/open-editor-lifecycle.v1.json';
    let OPEN_EDITOR_EVENTS = null;
    let OPEN_EDITOR_TIMING = null;

    function applyOpenEditorLifecycleContract(raw) {
      const events = raw?.events;
      const timing = raw?.timing;
      if (
        !events ||
        typeof events.openEditor !== 'string' ||
        typeof events.sessionReady !== 'string' ||
        typeof events.ack !== 'string' ||
        typeof events.applied !== 'string' ||
        typeof events.failed !== 'string' ||
        !timing ||
        typeof timing.ackRetryMs !== 'number' ||
        typeof timing.maxAckAttempts !== 'number' ||
        typeof timing.timeoutMs !== 'number'
      ) {
        throw new Error('[DevStudio] Invalid open-editor lifecycle contract');
      }
      OPEN_EDITOR_EVENTS = events;
      OPEN_EDITOR_TIMING = timing;
    }

    async function loadOpenEditorLifecycleContract() {
      const res = await fetch(`${OPEN_EDITOR_CONTRACT_PATH}?_t=${Date.now()}`, { cache: 'no-store' });
      if (!res.ok) {
        throw new Error(`[DevStudio] Failed to load open-editor lifecycle contract (HTTP ${res.status})`);
      }
      const payload = await res.json().catch(() => null);
      applyOpenEditorLifecycleContract(payload);
    }

    // This page is rendered inside DevStudio’s SPA shell. When navigating between tools,
    // DevStudio swaps DOM but does not automatically remove global event listeners.
    // Use an AbortController keyed on `window` so re-entering this tool page doesn't
    // accumulate listeners and spam postMessage loops.
    const CK_DEV_WIDGET_WORKSPACE_ABORT_KEY = '__CK_DEV_WIDGET_WORKSPACE_ABORT__';
    try {
      const prev = window[CK_DEV_WIDGET_WORKSPACE_ABORT_KEY];
      if (prev && typeof prev.abort === 'function') prev.abort();
    } catch {}
    const abortController = new AbortController();
    try {
      window[CK_DEV_WIDGET_WORKSPACE_ABORT_KEY] = abortController;
    } catch {}

    const pageParams = new URLSearchParams(window.location.search);

    function resolveRuntimeProfile(params) {
      const fromQuery = (params.get('runtimeProfile') || '').trim().toLowerCase();
      if (fromQuery === 'local' || fromQuery === 'cloud') return fromQuery;
      const fromGlobal =
        typeof window.__CK_DEVSTUDIO_RUNTIME_PROFILE__ === 'string'
          ? window.__CK_DEVSTUDIO_RUNTIME_PROFILE__.trim().toLowerCase()
          : '';
      if (fromGlobal === 'local' || fromGlobal === 'cloud') return fromGlobal;
      const origin = String(window.location.origin || '').trim().toLowerCase();
      if (origin.startsWith('http://localhost:') || origin.startsWith('http://127.0.0.1:')) {
        return 'local';
      }
      throw new Error(
        '[DevStudio] Missing runtimeProfile. Add ?runtimeProfile=local|cloud or set __CK_DEVSTUDIO_RUNTIME_PROFILE__.',
      );
    }

    const runtimeProfile = resolveRuntimeProfile(pageParams);
    const isLocalDevStudio = runtimeProfile === 'local';

    function requireBobOrigin(params, profile) {
      const fromGlobal =
        typeof window.__CK_DEVSTUDIO_BOB_ORIGIN__ === 'string'
          ? window.__CK_DEVSTUDIO_BOB_ORIGIN__.trim()
          : '';
      const defaultBob = profile === 'local' ? 'http://localhost:3000' : 'https://bob.dev.clickeen.com';
      const raw = (params.get('bob') || fromGlobal || defaultBob).trim();
      try {
        return new URL(raw).origin;
      } catch {
        throw new Error(`Invalid ?bob= origin: "${raw}"`);
      }
    }

    const BOB_ORIGIN = requireBobOrigin(pageParams, runtimeProfile);
    const PARIS_API = `${BOB_ORIGIN}/api/paris`;

    function resolveTokyoBaseUrl(params, profile) {
      const fromQuery = (params.get('tokyo') || '').trim();
      if (fromQuery) {
        try {
          return new URL(fromQuery).origin;
        } catch {
          throw new Error(`Invalid ?tokyo= origin: "${fromQuery}"`);
        }
      }
      const fromGlobal =
        typeof window.__CK_DEVSTUDIO_TOKYO_BASE_URL__ === 'string'
          ? window.__CK_DEVSTUDIO_TOKYO_BASE_URL__.trim()
          : '';
      if (fromGlobal) {
        try {
          return new URL(fromGlobal).origin;
        } catch {
          throw new Error(`Invalid __CK_DEVSTUDIO_TOKYO_BASE_URL__: "${fromGlobal}"`);
        }
      }
      return profile === 'local' ? 'http://localhost:4000' : 'https://tokyo.dev.clickeen.com';
    }

    const TOKYO_BASE = resolveTokyoBaseUrl(pageParams, runtimeProfile);
    const DEFAULT_INSTANCE_DISPLAY_NAME = 'Untitled widget';
    const URL_UUID_PATTERN =
      /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    const queryWorkspaceId = readQueryUuidParam(pageParams.get('workspaceId'));
    const queryCuratedWorkspaceId = readQueryUuidParam(pageParams.get('curatedWorkspaceId'));
    let bootstrapWorkspaceIdPromise = null;
    let currentPublicId = null;
    let selectedWidgetSlug = null;
    let instances = [];
    let isOpen = false;
    let bobSessionId = '';
    const dropdown = document.getElementById('instance-dropdown');
    const widgetSelector = document.getElementById('widget-selector');
    const widgetSelect = document.getElementById('widget-select');
    const control = document.getElementById('instance-dropdown-control');
    const valueField = document.getElementById('instance-dropdown-value');
    const menu = document.getElementById('instance-dropdown-menu');
    const iframe = document.getElementById('bob-iframe');
    const currentLabel = document.getElementById('current-instance-label');
    const compiledCache = new Map();
    const compiledPromiseCache = new Map();
    const instancePayloadPromiseCache = new Map();
    let sendInstanceSeq = 0;
    const privilegedActions = document.getElementById('privileged-actions');
    const privilegedUpdateDefaults = document.getElementById('privileged-update-defaults');
    const privilegedUpdateTheme = document.getElementById('privileged-update-theme');
    const privilegedResetFromJson = document.getElementById('privileged-reset-from-json');
    const createCuratedInstanceBtn = document.getElementById('create-curated-instance');
    const updateCuratedInstanceBtn = document.getElementById('update-curated-instance');
    const refreshPraguePreviewBtn = document.getElementById('refresh-prague-preview');
    const translateSelectedLocalesBtn = document.getElementById('translate-selected-locales');
    const l10nStatus = document.getElementById('l10n-status');
    const l10nStatusValue = document.getElementById('l10n-status-value');
    const l10nStatusMeta = document.getElementById('l10n-status-meta');
    const l10nStatusTooltip = document.getElementById('l10n-status-tooltip');
    const curatedModal = document.getElementById('curated-modal');
    const curatedModalTitle = document.getElementById('curated-modal-title');
    const curatedModalSubtitle = document.getElementById('curated-modal-subtitle');
    const curatedModalClose = document.getElementById('curated-modal-close');
    const curatedModalCancel = document.getElementById('curated-modal-cancel');
    const curatedModalConfirm = document.getElementById('curated-modal-confirm');
    const curatedStyleNameField = document.getElementById('curated-style-name');
    const curatedVariantPrimaryField = document.getElementById('curated-variant-primary');
    const curatedVariantSecondaryField = document.getElementById('curated-variant-secondary');
    const curatedStylePreview = document.getElementById('curated-style-preview');
    const themeModal = document.getElementById('theme-modal');
    const themeModalClose = document.getElementById('theme-modal-close');
    const themeModalCancel = document.getElementById('theme-modal-cancel');
    const themeModalConfirm = document.getElementById('theme-modal-confirm');
    const themeModalSelect = document.getElementById('theme-modal-select');
    let l10nStatusTimer = null;

    const THEME_UPDATE_LAST_ID_STORAGE = 'ck.devstudio.theme.update.lastThemeId';

    let curatedModalState = null;
    let themeModalState = null;

    function initBobIframe() {
      const bobUrl = new URL(`${BOB_ORIGIN}/bob`);
      bobUrl.searchParams.set('boot', 'message');
      bobUrl.searchParams.set('subject', 'workspace');
      bobUrl.searchParams.set('surface', 'devstudio');
      if (!isLocalDevStudio) bobUrl.searchParams.set('readonly', '1');
      iframe.src = bobUrl.toString();
    }

    function readQueryUuidParam(rawValue) {
      const value = typeof rawValue === 'string' ? rawValue.trim() : '';
      if (!value) return '';
      return URL_UUID_PATTERN.test(value) ? value : '';
    }

    async function loadBootstrapWorkspaceId() {
      if (bootstrapWorkspaceIdPromise) return bootstrapWorkspaceIdPromise;
      bootstrapWorkspaceIdPromise = (async () => {
        try {
          const res = await fetch(`${PARIS_API}/roma/bootstrap?_t=${Date.now()}`, {
            cache: 'no-store',
          });
          if (!res.ok) return '';
          const payload = await res.json().catch(() => null);
          const defaults =
            payload && typeof payload === 'object' && payload.defaults && typeof payload.defaults === 'object'
              ? payload.defaults
              : null;
          const workspaceId = defaults && typeof defaults.workspaceId === 'string' ? defaults.workspaceId.trim() : '';
          return URL_UUID_PATTERN.test(workspaceId) ? workspaceId : '';
        } catch {
          return '';
        }
      })();
      return bootstrapWorkspaceIdPromise;
    }

    async function resolveStandardWorkspaceId() {
      if (queryWorkspaceId) return queryWorkspaceId;
      const workspaceId = await loadBootstrapWorkspaceId();
      if (workspaceId) return workspaceId;
      throw new Error(
        '[DevStudio] Missing workspaceId. Add ?workspaceId=<uuid> or ensure /api/paris/roma/bootstrap returns defaults.workspaceId.',
      );
    }

    async function resolveCuratedWorkspaceId() {
      if (queryCuratedWorkspaceId) return queryCuratedWorkspaceId;
      return resolveStandardWorkspaceId();
    }

    async function resolveWorkspaceIdForPublicId(publicId) {
      const resolvedPublicId = String(publicId || '').trim();
      if (isCuratedPublicId(resolvedPublicId) || resolvedPublicId.startsWith('wgt_main_')) {
        return resolveCuratedWorkspaceId();
      }
      return resolveStandardWorkspaceId();
    }

    function setL10nStatusDisplay({ state, tone, value, meta }) {
      if (!(l10nStatus instanceof HTMLElement)) return;
      l10nStatus.dataset.state = state || 'idle';
      l10nStatus.dataset.tone = tone || 'unavailable';
      const valueLabel = value || '-';
      const metaLabel = meta || '';
      if (l10nStatusValue instanceof HTMLElement) l10nStatusValue.textContent = valueLabel;
      if (l10nStatusMeta instanceof HTMLElement) {
        l10nStatusMeta.textContent = metaLabel;
      }
      const hoverDetails = [valueLabel, metaLabel].filter(Boolean).join(' · ');
      if (l10nStatusTooltip instanceof HTMLElement) {
        l10nStatusTooltip.textContent = hoverDetails || 'No status details available.';
      }
      if (hoverDetails && valueLabel !== '-') {
        l10nStatus.setAttribute('aria-label', `Translations status: ${hoverDetails}`);
      } else {
        l10nStatus.setAttribute('aria-label', 'Translations status');
      }
      l10nStatus.removeAttribute('title');
    }

    function summarizePublishStatus(payload) {
      const locales = Array.isArray(payload?.locales) ? payload.locales : [];
      const total = locales.length;
      const summary =
        payload?.summary && typeof payload.summary === 'object' ? payload.summary : {};
      const l10nSummary = summary?.l10n && typeof summary.l10n === 'object' ? summary.l10n : {};
      const pipelineL10n =
        payload?.pipeline?.l10n && typeof payload.pipeline.l10n === 'object'
          ? payload.pipeline.l10n
          : {};
      const nonBaseLocales = locales.filter((entry) => entry?.locale !== 'en');
      const pointerFlipped =
        typeof summary.pointerFlipped === 'number'
          ? summary.pointerFlipped
          : locales.filter((entry) => entry?.stage === 'pointer_flipped').length;
      const awaitingL10n =
        typeof summary.awaitingL10n === 'number'
          ? summary.awaitingL10n
          : locales.filter((entry) => entry?.stage === 'awaiting_l10n').length;
      const awaitingSnapshot =
        typeof summary.awaitingSnapshot === 'number'
          ? summary.awaitingSnapshot
          : locales.filter((entry) => entry?.stage === 'awaiting_snapshot').length;
      const failed =
        typeof summary.failed === 'number'
          ? summary.failed
          : locales.filter((entry) => entry?.stage === 'failed').length;
      const unpublished =
        typeof summary.unpublished === 'number'
          ? summary.unpublished
          : locales.filter((entry) => entry?.stage === 'unpublished').length;
      const dirty =
        typeof l10nSummary.dirty === 'number'
          ? l10nSummary.dirty
          : nonBaseLocales.filter((entry) => entry?.l10n?.status === 'dirty').length;
      const queued =
        typeof l10nSummary.queued === 'number'
          ? l10nSummary.queued
          : nonBaseLocales.filter((entry) => entry?.l10n?.status === 'queued').length;
      const running =
        typeof l10nSummary.running === 'number'
          ? l10nSummary.running
          : nonBaseLocales.filter((entry) => entry?.l10n?.status === 'running').length;
      const retrying =
        typeof l10nSummary.retrying === 'number'
          ? l10nSummary.retrying
          : nonBaseLocales.filter(
              (entry) => entry?.l10n?.status === 'failed' && Boolean(entry?.l10n?.nextAttemptAt),
            ).length;
      const failedTerminal =
        typeof l10nSummary.failedTerminal === 'number'
          ? l10nSummary.failedTerminal
          : nonBaseLocales.filter(
              (entry) => entry?.l10n?.status === 'failed' && !entry?.l10n?.nextAttemptAt,
            ).length;
      const superseded =
        typeof l10nSummary.superseded === 'number'
          ? l10nSummary.superseded
          : nonBaseLocales.filter((entry) => entry?.l10n?.status === 'superseded').length;
      const inFlight =
        typeof l10nSummary.inFlight === 'number' ? l10nSummary.inFlight : queued + running;
      const needsEnqueue =
        typeof l10nSummary.needsEnqueue === 'number'
          ? l10nSummary.needsEnqueue
          : dirty + superseded;
      const stageReasons =
        pipelineL10n?.stageReasons && typeof pipelineL10n.stageReasons === 'object'
          ? pipelineL10n.stageReasons
          : {};
      const rawNextActionLabel =
        pipelineL10n?.nextAction &&
        typeof pipelineL10n.nextAction === 'object' &&
        typeof pipelineL10n.nextAction.label === 'string'
          ? pipelineL10n.nextAction.label.trim()
          : '';
      const fallbackNextActionLabel =
        failedTerminal > 0
          ? 'Inspect last error and requeue failed locales.'
          : needsEnqueue > 0
            ? 'Click "Translate" to enqueue stale locales.'
            : retrying > 0
              ? 'Retry backoff in progress; wait for next attempt.'
              : inFlight > 0
                ? 'Translations are running; wait for completion.'
                : awaitingSnapshot > 0
                  ? 'Waiting for snapshot publish.'
                  : '';
      const nextActionLabel = rawNextActionLabel || fallbackNextActionLabel;

      let label = 'Live';
      let tone = 'ready';

      if (unpublished > 0) {
        label = 'Draft';
        tone = 'unavailable';
      } else if (failedTerminal > 0 || (failed > 0 && retrying === 0)) {
        label = 'Failed';
        tone = 'unavailable';
      } else if (inFlight > 0) {
        label = 'Updating';
        tone = 'running';
      } else if (retrying > 0) {
        label = 'Retrying';
        tone = 'retrying';
      } else if (awaitingSnapshot > 0) {
        label = 'Publishing';
        tone = 'pending';
      } else if (needsEnqueue > 0 || awaitingL10n > 0) {
        label = 'Outdated';
        tone = 'pending';
      }

      const metaLive = total ? `${pointerFlipped}/${total} live` : '';
      const metaRunning = running > 0 ? `${running} running` : '';
      const metaQueued = queued > 0 ? `${queued} queued` : '';
      const metaRetrying = retrying > 0 ? `${retrying} retrying` : '';
      const metaOutdated = needsEnqueue > 0 ? `${needsEnqueue} stale` : '';
      const metaFailed = failedTerminal > 0 ? `${failedTerminal} failed` : '';
      const unresolvedAwaiting =
        awaitingL10n > inFlight + retrying + needsEnqueue
          ? awaitingL10n - (inFlight + retrying + needsEnqueue)
          : 0;
      const metaAwaiting = unresolvedAwaiting > 0 ? `${unresolvedAwaiting} pending` : '';
      const metaSnapshot = awaitingSnapshot > 0 ? `${awaitingSnapshot} snapshotting` : '';
      const firstLocaleError = locales.find((entry) => entry?.l10n?.lastError);
      const rawLocaleError = firstLocaleError?.l10n?.lastError
        ? String(firstLocaleError.l10n.lastError).trim()
        : '';
      const rawPipelineError =
        payload?.pipeline?.renderIndexError && typeof payload.pipeline.renderIndexError === 'string'
          ? payload.pipeline.renderIndexError.trim()
          : '';
      const rawL10nPipelineError =
        pipelineL10n?.overlayMatchError && typeof pipelineL10n.overlayMatchError === 'string'
          ? pipelineL10n.overlayMatchError.trim()
          : '';
      const rawError = rawLocaleError || rawPipelineError || rawL10nPipelineError;
      const metaError = rawError
        ? `Last error: ${rawError.length > 120 ? `${rawError.slice(0, 117)}...` : rawError}`
        : '';
      const stageReasonLabel = {
        l10n_running: 'running',
        l10n_queued: 'queued',
        l10n_retrying: 'retrying',
        l10n_failed_terminal: 'terminal failures',
        l10n_dirty: 'dirty',
        l10n_superseded: 'superseded',
        snapshot_missing: 'snapshot pending',
        instance_unpublished: 'instance unpublished',
      };
      const topReason = Object.entries(stageReasons)
        .filter(
          (entry) => typeof entry[0] === 'string' && typeof entry[1] === 'number' && entry[1] > 0,
        )
        .sort((a, b) => b[1] - a[1])[0];
      const metaWhy = topReason
        ? `Why: ${topReason[1]} ${stageReasonLabel[topReason[0]] || topReason[0]}`
        : '';
      const metaAction = nextActionLabel ? `Next: ${nextActionLabel}` : '';
      const meta = [
        metaLive,
        metaRunning,
        metaQueued,
        metaRetrying,
        metaOutdated,
        metaFailed,
        metaAwaiting,
        metaSnapshot,
        metaWhy,
        metaAction,
        metaError,
      ]
        .filter(Boolean)
        .join(' · ');
      const shouldPoll = inFlight > 0 || retrying > 0 || awaitingSnapshot > 0;
      return { label, tone, meta, shouldPoll };
    }

    async function refreshL10nStatus(publicId) {
      if (!publicId) {
        setL10nStatusDisplay({ state: 'hidden', tone: 'unavailable', value: '-', meta: '' });
        return;
      }

      if (l10nStatusTimer) {
        clearTimeout(l10nStatusTimer);
        l10nStatusTimer = null;
      }

      setL10nStatusDisplay({ state: 'loading', tone: 'pending', value: 'Loading...', meta: '' });

      try {
        const workspaceId = await resolveWorkspaceIdForPublicId(publicId);
        const res = await fetch(
          `${PARIS_API}/workspaces/${encodeURIComponent(workspaceId)}/instances/${encodeURIComponent(
            publicId,
          )}/publish/status?subject=workspace&_t=${Date.now()}`,
          { cache: 'no-store' },
        );
        const payload = await res.json().catch(() => null);

        if (!res.ok) {
          const reasonKey = payload?.error?.reasonKey || payload?.error?.code || null;
          if (res.status === 403 && String(reasonKey || '').includes('coreui.upsell')) {
            setL10nStatusDisplay({
              state: 'ready',
              tone: 'unavailable',
              value: 'Off',
              meta: 'Upgrade required',
            });
            return;
          }
          setL10nStatusDisplay({
            state: 'ready',
            tone: 'unavailable',
            value: 'Unavailable',
            meta: '',
          });
          return;
        }

        const locales = Array.isArray(payload?.locales) ? payload.locales : [];
        if (!locales.length) {
          setL10nStatusDisplay({
            state: 'ready',
            tone: 'unavailable',
            value: 'Off',
            meta: 'No active locales (EN only)',
          });
          return;
        }

        const summary = summarizePublishStatus(payload);
        setL10nStatusDisplay({
          state: 'ready',
          tone: summary.tone,
          value: summary.label,
          meta: summary.meta,
        });

        if (summary.shouldPoll) {
          l10nStatusTimer = setTimeout(() => {
            refreshL10nStatus(publicId).catch(() => {});
          }, 15000);
        }
      } catch (err) {
        console.error('[DevStudio] Failed to load l10n status', err);
        setL10nStatusDisplay({
          state: 'ready',
          tone: 'unavailable',
          value: 'Unavailable',
          meta: '',
        });
      }
    }

    let isPosting = false;
    window.addEventListener(
      'message',
      (event) => {
        if (event.origin !== BOB_ORIGIN) return;
        if (event.source !== iframe.contentWindow) return;
        const data = event.data;
        if (data && data.type === 'bob:request-instance-switch') {
          const publicId = typeof data.publicId === 'string' ? data.publicId.trim() : '';
          if (!publicId) return;
          if (!instances.some((inst) => inst.publicId === publicId)) return;
          switchInstance(publicId);
          return;
        }
        if (data && data.type === 'bob:instance-renamed') {
          const publicId = typeof data.publicId === 'string' ? data.publicId.trim() : '';
          const displayName = typeof data.displayName === 'string' ? data.displayName.trim() : '';
          if (!publicId || !displayName) return;
          const instance = instances.find((inst) => inst.publicId === publicId);
          if (!instance) return;
          instance.label = displayName;
          updateCurrentLabel();
          renderInstances();
          return;
        }
        if (data && data.type === OPEN_EDITOR_EVENTS.sessionReady) {
          const sessionId = typeof data.sessionId === 'string' ? data.sessionId.trim() : '';
          if (!sessionId) {
            console.error('[DevStudio] bob:session-ready missing sessionId');
            return;
          }
          if (data.bootMode && data.bootMode !== 'message') {
            console.error('[DevStudio] Bob bootMode mismatch', data.bootMode);
            return;
          }
          bobSessionId = sessionId;
          if (!currentPublicId) return;
          console.log('[DevStudio] Received bob:session-ready, posting instance', currentPublicId);
          if (isPosting) return;
          isPosting = true;
          Promise.resolve(sendInstanceToIframe(currentPublicId))
            .catch((error) => console.error('[DevStudio] Failed to send instance to Bob', error))
            .finally(() => {
              isPosting = false;
            });
        }
        if (data && data.type === 'bob:published') {
          const publicId = typeof data.publicId === 'string' ? data.publicId : '';
          const workspaceId = typeof data.workspaceId === 'string' ? data.workspaceId : '';
          const widgetType = typeof data.widgetType === 'string' ? data.widgetType : '';
          const config = data.config && typeof data.config === 'object' ? data.config : null;
          if (!publicId || !workspaceId || !widgetType || !config) return;
          refreshL10nStatus(publicId).catch(() => {});
        }
      },
      { signal: abortController.signal },
    );

    function attachDropdown() {
      const header = document.querySelector('.devstudio-page__header');
      if (!header || !dropdown || !widgetSelector) {
        requestAnimationFrame(attachDropdown);
        return;
      }
      header.classList.add('dev-widget-workspace-header');
      header.appendChild(widgetSelector);
      dropdown.style.display = 'inline-block';
      header.appendChild(dropdown);
    }
    attachDropdown();

    function normalizeWidgetname(raw) {
      if (!raw) return null;
      if (/^[a-z0-9_]+$/.test(raw)) return raw;
      const parts = String(raw)
        .split(/[^a-z0-9_]+/i)
        .filter(Boolean);
      if (!parts.length) return null;
      return parts[parts.length - 1].toLowerCase();
    }

    function formatWidgetLabel(widgetSlug) {
      const slug = normalizeWidgetname(widgetSlug);
      if (!slug) return 'Unknown';
      return slug
        .split(/[_-]+/g)
        .filter(Boolean)
        .map((part) => part.slice(0, 1).toUpperCase() + part.slice(1))
        .join(' ');
    }

    function listWidgetSlugs() {
      return Array.from(
        new Set(instances.map((inst) => inst.widgetSlug).filter((slug) => typeof slug === 'string' && slug)),
      ).sort((a, b) => a.localeCompare(b));
    }

    function getScopedInstances() {
      if (!selectedWidgetSlug) return instances;
      return instances.filter((inst) => inst.widgetSlug === selectedWidgetSlug);
    }

    function syncWidgetSelector() {
      if (!(widgetSelect instanceof HTMLSelectElement)) return;
      const widgetSlugs = listWidgetSlugs();
      widgetSelect.replaceChildren();
      widgetSlugs.forEach((widgetSlug) => {
        const option = document.createElement('option');
        option.value = widgetSlug;
        option.textContent = formatWidgetLabel(widgetSlug);
        widgetSelect.appendChild(option);
      });
      if (!widgetSlugs.length) {
        selectedWidgetSlug = null;
        if (widgetSelector instanceof HTMLElement) widgetSelector.style.display = 'none';
        return;
      }
      if (!selectedWidgetSlug || !widgetSlugs.includes(selectedWidgetSlug)) {
        selectedWidgetSlug = widgetSlugs[0];
      }
      widgetSelect.value = selectedWidgetSlug;
      if (widgetSelector instanceof HTMLElement) {
        widgetSelector.style.display = widgetSlugs.length > 1 ? 'block' : 'none';
      }
    }

    function syncSelectedWidgetForPublicId(publicId) {
      const selected = instances.find((inst) => inst.publicId === publicId);
      const widgetSlug = selected?.widgetSlug || normalizeWidgetname(selected?.widgetname);
      if (!widgetSlug) return;
      if (widgetSlug === selectedWidgetSlug) return;
      selectedWidgetSlug = widgetSlug;
      syncWidgetSelector();
    }

    async function ensureCompiledWidget(widgetname) {
      const slug = normalizeWidgetname(widgetname);
      if (!slug) throw new Error(`Cannot normalize widget name: ${widgetname}`);
      if (compiledCache.has(slug)) return compiledCache.get(slug);
      if (compiledPromiseCache.has(slug)) return compiledPromiseCache.get(slug);

      const promise = (async () => {
        const res = await fetch(`${BOB_ORIGIN}/api/widgets/${slug}/compiled`, { cache: 'no-store' });
        if (!res.ok) {
          let details = '';
          try {
            const text = await res.text();
            if (text) {
              try {
                const parsed = JSON.parse(text);
                if (parsed && typeof parsed === 'object' && 'error' in parsed) {
                  details = String(parsed.error || '');
                } else {
                  details = text;
                }
              } catch {
                details = text;
              }
            }
          } catch {}
          const suffix = details ? ` → ${details}` : '';
          throw new Error(`Failed to compile widget ${widgetname} (${res.status})${suffix}`);
        }
        const json = await res.json();
        compiledCache.set(slug, json);
        return json;
      })().finally(() => {
        compiledPromiseCache.delete(slug);
      });

      compiledPromiseCache.set(slug, promise);
      return promise;
    }

    async function fetchInstancePayload(publicId, workspaceId) {
      const resolvedWorkspaceId =
        typeof workspaceId === 'string' && workspaceId.trim()
          ? workspaceId.trim()
          : await resolveWorkspaceIdForPublicId(publicId);
      const cacheKey = `${resolvedWorkspaceId}::${publicId}`;
      if (instancePayloadPromiseCache.has(cacheKey)) {
        return instancePayloadPromiseCache.get(cacheKey);
      }
      const promise = (async () => {
        const res = await fetch(
          `${PARIS_API}/workspaces/${encodeURIComponent(resolvedWorkspaceId)}/instance/${encodeURIComponent(
            publicId,
          )}?subject=workspace&_t=${Date.now()}`,
          { cache: 'no-store' },
        );
        if (!res.ok) throw new Error(`Failed to load instance ${publicId} (${res.status})`);
        const json = await res.json();
        if (!json || typeof json !== 'object') {
          throw new Error(`[DevStudio] Invalid instance payload for ${publicId}`);
        }
        return json;
      })().finally(() => {
        instancePayloadPromiseCache.delete(cacheKey);
      });

      instancePayloadPromiseCache.set(cacheKey, promise);
      return promise;
    }

    async function fetchInstances() {
      console.log('[DevStudio] Fetching instances from Paris');
      const res = await fetch(`${PARIS_API}/curated-instances?includeConfig=0&_t=${Date.now()}`, {
        cache: 'no-store',
      });
      if (!res.ok) {
        const text = await res.text().catch(() => '');
        let detail = text;
        try {
          const parsed = JSON.parse(text);
          if (parsed && typeof parsed === 'object' && parsed.error) {
            detail = parsed.error?.reasonKey
              ? String(parsed.error.reasonKey)
              : JSON.stringify(parsed.error);
          }
        } catch {}
        throw new Error(
          `[DevStudio] Failed to fetch instances (HTTP ${res.status})${detail ? `: ${detail}` : ''}`,
        );
      }
      const data = await res.json();
      const payload = Array.isArray(data.instances) ? data.instances : [];
      instances = payload.map((inst) => ({
        publicId: inst.publicId,
        widgetname: inst.widgetname,
        widgetSlug: normalizeWidgetname(inst.widgetname),
        label:
          typeof inst.displayName === 'string' && inst.displayName.trim()
            ? inst.displayName.trim()
            : DEFAULT_INSTANCE_DISPLAY_NAME,
        config: inst.config ?? null,
        meta: normalizeCuratedMeta(inst.meta ?? null),
      }));

      if (instances.length === 0) {
        selectedWidgetSlug = null;
        currentPublicId = null;
        currentLabel.textContent = 'No instances yet';
        valueField.value = '';
        menu.innerHTML = '';
        dropdown.style.display = 'none';
        if (widgetSelector instanceof HTMLElement) widgetSelector.style.display = 'none';
        return;
      }
      dropdown.style.display = 'inline-block';

      if (!instances.some((inst) => inst.publicId === currentPublicId)) {
        currentPublicId = instances[0].publicId;
      }
      syncSelectedWidgetForPublicId(currentPublicId);
      syncWidgetSelector();

      const scopedInstances = getScopedInstances();
      if (!scopedInstances.some((inst) => inst.publicId === currentPublicId)) {
        currentPublicId = scopedInstances[0]?.publicId || instances[0].publicId;
      }

      console.log('[DevStudio] Current publicId', currentPublicId, 'instances', instances.length);
      updateCurrentLabel();
      renderInstances();
      sendInstanceToIframe(currentPublicId).catch((error) => {
        console.error('[DevStudio] Failed to load initial instance into Bob', error);
      });
      refreshL10nStatus(currentPublicId).catch(() => {});
    }

    function updateCurrentLabel() {
      if (!currentPublicId) {
        currentLabel.textContent = 'No instances yet';
        valueField.value = '';
        return;
      }
      const current = instances.find((inst) => inst.publicId === currentPublicId);
      currentLabel.textContent = current?.label || DEFAULT_INSTANCE_DISPLAY_NAME;
      valueField.value = currentPublicId;
    }

    function renderInstances() {
      const scopedInstances = getScopedInstances();
      if (!scopedInstances.length) {
        menu.innerHTML = '<div class="dev-widget-workspace__empty-option body-s">No instances</div>';
        return;
      }

      menu.innerHTML = scopedInstances
        .map((inst) => {
          const selected = inst.publicId === currentPublicId;
          return `
        <button
          type="button"
          class="diet-btn-menuactions diet-dropdown__option${selected ? ' is-selected' : ''}"
          role="option"
          data-public-id="${inst.publicId}"
          aria-selected="${selected ? 'true' : 'false'}"
        >
          <span class="diet-btn-menuactions__label">${inst.label}</span>
          <span class="diet-btn-menuactions__icon" aria-hidden="true">
            <svg viewBox="0 0 16 16" fill="none">
              <path d="M4 8l3 3 5-6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </span>
        </button>
      `;
        })
        .join('');

      menu.querySelectorAll('[data-public-id]').forEach((button) => {
        button.addEventListener('click', () => {
          const publicId = button.getAttribute('data-public-id');
          if (!publicId) return;
          switchInstance(publicId);
        });
      });
    }

    function switchInstance(publicId) {
      syncSelectedWidgetForPublicId(publicId);
      currentPublicId = publicId;
      isOpen = false;
      dropdown.setAttribute('data-state', 'closed');
      control.setAttribute('aria-expanded', 'false');
      updateCurrentLabel();
      renderInstances();
      sendInstanceToIframe(publicId).catch((error) => {
        console.error('[DevStudio] Failed to send instance to Bob', error);
      });
      refreshL10nStatus(publicId).catch(() => {});
    }

    async function privilegedActionsFetch(url, init) {
      return fetch(url, init);
    }

    function requireWidgetSlugForAction() {
      const current = instances.find((inst) => inst.publicId === currentPublicId);
      const fallback = current?.widgetSlug || normalizeWidgetname(current?.widgetname) || 'faq';
      const entered = window.prompt('Widget type (slug):', fallback);
      const slug = normalizeWidgetname(entered);
      if (!slug) throw new Error('[DevStudio] Missing widget type');
      return slug;
    }

    function slugifyKey(raw) {
      return String(raw || '')
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '');
    }

    function escapeRegExp(raw) {
      return String(raw || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function normalizeCuratedNameSegment(raw, widgetSlug) {
      const normalizedWidgetSlug = normalizeWidgetname(widgetSlug);
      let value = String(raw || '').trim();
      if (!value) return '';

      value = value.replace(/^wgt_(?:curated|main)_/i, '');
      if (normalizedWidgetSlug) {
        const widgetPrefix = new RegExp(`^${escapeRegExp(normalizedWidgetSlug)}[._\\s-]*`, 'i');
        value = value.replace(widgetPrefix, '');
      }
      value = value.replace(/[._\s-]*v\d+$/i, '');
      return value.trim();
    }

    function isCuratedPublicId(publicId) {
      return typeof publicId === 'string' && /^wgt_curated_[a-z0-9][a-z0-9_-]*$/i.test(publicId);
    }

    function parseCuratedPublicId(publicId, widgetSlugHint) {
      if (!isCuratedPublicId(publicId)) return null;
      const widgetSlug = normalizeWidgetname(widgetSlugHint);
      if (!widgetSlug) return null;
      const match = new RegExp(`^wgt_curated_${escapeRegExp(widgetSlug)}_([a-z0-9][a-z0-9_-]*)$`, 'i').exec(publicId);
      if (!match) return null;
      return { widgetSlug, styleSlug: match[1] || null };
    }

    function normalizeCuratedVariants(raw) {
      if (!raw || typeof raw !== 'object' || Array.isArray(raw)) {
        return {
          primary: null,
          secondary: null,
        };
      }
      const primary = typeof raw.primary === 'string' ? raw.primary.trim() : '';
      const secondary = typeof raw.secondary === 'string' ? raw.secondary.trim() : '';
      return {
        primary: primary || null,
        secondary: secondary || null,
      };
    }

    function normalizeCuratedMeta(raw) {
      if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;
      const styleName = typeof raw.styleName === 'string' ? raw.styleName.trim() : '';
      const styleSlug = typeof raw.styleSlug === 'string' ? raw.styleSlug.trim() : '';
      const variants = normalizeCuratedVariants(raw.variants || raw.variant || null);
      return {
        styleName: styleName || null,
        styleSlug: styleSlug || null,
        variants,
      };
    }

    function resolveCuratedStyle(instance) {
      if (!instance) return null;
      const meta = normalizeCuratedMeta(instance.meta);
      const parsed = parseCuratedPublicId(instance.publicId, instance.widgetSlug);
      const styleSlug = meta?.styleSlug || parsed?.styleSlug || null;
      const styleName = meta?.styleName || (styleSlug ? styleSlug.replace(/_/g, '.') : null);
      const variants = meta?.variants ?? normalizeCuratedVariants(null);
      return {
        styleName,
        styleSlug,
        variants,
        widgetSlug: instance.widgetSlug || parsed?.widgetSlug || null,
      };
    }

    function buildCuratedPublicId(widgetSlug, styleSlug) {
      const normalizedWidgetSlug = normalizeWidgetname(widgetSlug);
      const normalizedStyleSlug = slugifyKey(styleSlug);
      if (!normalizedWidgetSlug || !normalizedStyleSlug) {
        throw new Error('[DevStudio] Invalid curated instance key.');
      }
      return `wgt_curated_${normalizedWidgetSlug}_${normalizedStyleSlug}`;
    }

    async function createWorkspaceInstance({
      workspaceId,
      widgetType,
      publicId,
      config,
      status,
      meta,
    }) {
      const res = await privilegedActionsFetch(
        `${PARIS_API}/workspaces/${encodeURIComponent(workspaceId)}/instances?subject=workspace&_t=${Date.now()}`,
        {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ widgetType, publicId, config, status, meta }),
        },
      );
      const text = await res.text().catch(() => '');
      if (!res.ok)
        throw new Error(
          `[DevStudio] Create instance failed (HTTP ${res.status})${text ? `: ${text}` : ''}`,
        );
      return text ? JSON.parse(text) : null;
    }

    async function updateWorkspaceInstance({ workspaceId, publicId, config, status, meta }) {
      const res = await privilegedActionsFetch(
        `${PARIS_API}/workspaces/${encodeURIComponent(workspaceId)}/instance/${encodeURIComponent(
          publicId,
        )}?subject=workspace&_t=${Date.now()}`,
        {
          method: 'PUT',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ config, status, meta }),
        },
      );
      const text = await res.text().catch(() => '');
      if (!res.ok)
        throw new Error(
          `[DevStudio] Update instance failed (HTTP ${res.status})${text ? `: ${text}` : ''}`,
        );
      return text ? JSON.parse(text) : null;
    }

    async function ensureWorkspaceInstance({ workspaceId, widgetType, publicId, config, status }) {
      const res = await privilegedActionsFetch(
        `${PARIS_API}/workspaces/${encodeURIComponent(workspaceId)}/instances?subject=workspace&_t=${Date.now()}`,
        {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ widgetType, publicId, config, status }),
        },
      );
      if (res.ok) {
        const text = await res.text().catch(() => '');
        return text ? JSON.parse(text) : null;
      }

      // If the instance already exists, update it to the desired config/status.
      const text = await res.text().catch(() => '');
      if (res.status === 409 || (text || '').toLowerCase().includes('duplicate')) {
        await updateWorkspaceInstance({ workspaceId, publicId, config, status });
        return { ok: true, existed: true };
      }

      throw new Error(
        `[DevStudio] Ensure instance failed (HTTP ${res.status})${text ? `: ${text}` : ''}`,
      );
    }

    async function exportInstanceDataFromBob({
      timeoutMs = 2500,
      persistAssets = false,
      exportMode = 'base',
      assetScope = 'workspace',
      assetPublicId,
      assetWidgetType,
    } = {}) {
      const target = iframe.contentWindow;
      if (!target) throw new Error('[DevStudio] Bob iframe not ready');
      const requestId = crypto.randomUUID();

      return await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          cleanup();
          reject(new Error('[DevStudio] Timed out requesting instance data from Bob'));
        }, timeoutMs);

        const cleanup = () => {
          clearTimeout(timeout);
          window.removeEventListener('message', onMessage);
        };

        const onMessage = (event) => {
          if (event.origin !== BOB_ORIGIN) return;
          const data = event.data;
          if (!data || typeof data !== 'object') return;
          if (data.type !== 'bob:export-instance-data') return;
          if (data.requestId !== requestId) return;
          cleanup();
          if (data.ok !== true) {
            reject(new Error(data.error || '[DevStudio] Bob failed to export instance data'));
            return;
          }
          resolve(data);
        };

        window.addEventListener('message', onMessage);
        target.postMessage(
          {
            type: 'devstudio:export-instance-data',
            requestId,
            persistAssets,
            exportMode,
            assetScope,
            assetPublicId,
            assetWidgetType,
          },
          BOB_ORIGIN,
        );
      });
    }

    function cloneJson(value) {
      // v1: config is JSON-only.
      return JSON.parse(JSON.stringify(value ?? null));
    }

    function extractPrimaryUrl(raw) {
      const v = String(raw || '').trim();
      if (!v) return null;
      if (/^(?:data|blob):/i.test(v) || /^https?:\/\//i.test(v)) return v;
      const m = v.match(/url\(\s*(['"]?)([^'")]+)\1\s*\)/i);
      if (m && m[2]) return m[2];
      return null;
    }

    function replacePrimaryUrl(raw, nextUrl) {
      const v = String(raw || '');
      const m = v.match(/url\(\s*(['"]?)([^'")]+)\1\s*\)/i);
      if (m && m[2]) return v.replace(m[2], nextUrl);
      return nextUrl;
    }

    function isNonPersistableUrl(rawUrl) {
      const v = String(rawUrl || '').trim();
      return /^(?:data|blob):/i.test(v);
    }

    function extFromMime(mime) {
      const mt = String(mime || '').toLowerCase();
      if (mt === 'image/png') return 'png';
      if (mt === 'image/jpeg') return 'jpg';
      if (mt === 'image/webp') return 'webp';
      if (mt === 'image/gif') return 'gif';
      if (mt === 'image/svg+xml') return 'svg';
      if (mt === 'video/mp4') return 'mp4';
      if (mt === 'video/webm') return 'webm';
      if (mt === 'application/pdf') return 'pdf';
      return 'bin';
    }

    async function uploadTokyoAsset({
      scope,
      accountId,
      workspaceId,
      widgetType,
      publicId,
      blob,
      filename,
      variant = 'original',
    }) {
      const headers = new Headers();
      headers.set('content-type', blob.type || 'application/octet-stream');
      headers.set('x-filename', filename || 'upload.bin');
      headers.set('x-variant', variant);
      if (scope !== 'widget') {
        if (!accountId) throw new Error('[DevStudio] Missing accountId for account asset upload');
        headers.set('x-account-id', accountId);
        headers.set('x-source', 'devstudio');
      }

      let endpoint = '';
      if (scope === 'workspace') {
        if (workspaceId) headers.set('x-workspace-id', workspaceId);
        endpoint = `${BOB_ORIGIN}/api/assets/upload`;
      } else if (scope === 'curated') {
        if (!publicId) throw new Error('[DevStudio] Missing publicId for curated asset upload');
        const normalized =
          normalizeWidgetname(widgetType) ||
          String(widgetType || '')
            .trim()
            .toLowerCase();
        if (!normalized) throw new Error('[DevStudio] Missing widgetType for curated asset upload');
        headers.set('x-public-id', publicId);
        headers.set('x-widget-type', normalized);
        endpoint = `${BOB_ORIGIN}/api/assets/upload`;
      } else if (scope === 'widget') {
        const normalized =
          normalizeWidgetname(widgetType) ||
          String(widgetType || '')
            .trim()
            .toLowerCase();
        if (!normalized) throw new Error('[DevStudio] Missing widgetType for widget asset upload');
        headers.set('x-widget-type', normalized);
        endpoint = `${TOKYO_BASE}/widgets/upload`;
      } else {
        throw new Error(`[DevStudio] Unknown asset upload scope: ${String(scope)}`);
      }

      const res = await fetch(`${endpoint}?_t=${Date.now()}`, {
        method: 'POST',
        headers,
        body: blob,
      });
      const text = await res.text().catch(() => '');
      if (!res.ok) {
        throw new Error(
          `[DevStudio] Asset upload failed (HTTP ${res.status})${text ? `: ${text}` : ''}`,
        );
      }
      const json = text ? JSON.parse(text) : null;
      const keyCandidate =
        typeof json?.key === 'string'
          ? json.key.trim()
          : typeof json?.relativePath === 'string'
            ? json.relativePath.trim()
            : '';
      const directUrl = typeof json?.url === 'string' ? json.url.trim() : '';
      const tokyoBase = TOKYO_BASE.replace(/\/+$/, '');
      const normalizeAbsoluteToBase = (raw) => {
        const value = String(raw || '').trim();
        if (!value) return '';
        try {
          const parsed = new URL(value);
          return `${tokyoBase}${parsed.pathname}`;
        } catch {
          return value;
        }
      };
      const normalizedUrl =
        keyCandidate
          ? /^https?:\/\//i.test(keyCandidate)
            ? normalizeAbsoluteToBase(keyCandidate)
            : `${tokyoBase}/${keyCandidate.replace(/^\/+/, '')}`
          : directUrl
            ? /^https?:\/\//i.test(directUrl)
              ? normalizeAbsoluteToBase(directUrl)
              : directUrl
            : '';
      if (!normalizedUrl) throw new Error('[DevStudio] Asset upload missing url');
      return normalizedUrl;
    }

    async function persistConfigAssetsToTokyo(
      config,
      { scope, accountId, workspaceId, widgetType, publicId },
    ) {
      if (!config || typeof config !== 'object') return config;

      const cache = new Map();
      const visit = async (node) => {
        if (typeof node === 'string') {
          const url = extractPrimaryUrl(node);
          if (!url || !isNonPersistableUrl(url)) return;

          if (!cache.has(url)) {
            const blob = await fetch(url).then((r) => r.blob());
            const ext = extFromMime(blob.type);
            const filename = `upload.${ext}`;
            const uploadedUrl = await uploadTokyoAsset({
              scope,
              accountId,
              workspaceId,
              widgetType,
              publicId,
              blob,
              filename,
              variant: 'original',
            });
            cache.set(url, uploadedUrl);
          }
          const uploaded = cache.get(url);
          return replacePrimaryUrl(node, uploaded);
        }

        if (!node || typeof node !== 'object') return;
        if (Array.isArray(node)) {
          for (let i = 0; i < node.length; i += 1) {
            const replaced = await visit(node[i]);
            if (typeof replaced === 'string') node[i] = replaced;
          }
          return;
        }

        for (const [key, value] of Object.entries(node)) {
          const replaced = await visit(value);
          if (typeof replaced === 'string') node[key] = replaced;
        }
      };

      await visit(config);
      return config;
    }

    function stripTokyoBaseFromConfig(config, tokyoBase) {
      if (!config || typeof config !== 'object') return config;
      const base = String(tokyoBase || '')
        .trim()
        .replace(/\/+$/, '');
      if (!base) return config;
      const escaped = base.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const baseRegex = new RegExp(escaped, 'g');

      const visit = (node) => {
        if (typeof node === 'string') {
          if (!node.includes(base)) return;
          return node.replace(baseRegex, '');
        }
        if (!node || typeof node !== 'object') return;
        if (Array.isArray(node)) {
          for (let i = 0; i < node.length; i += 1) {
            const replaced = visit(node[i]);
            if (typeof replaced === 'string') node[i] = replaced;
          }
          return;
        }
        for (const [key, value] of Object.entries(node)) {
          const replaced = visit(value);
          if (typeof replaced === 'string') node[key] = replaced;
        }
      };

      visit(config);
      return config;
    }

    async function updateDefaultsMainInstanceFromEditor(widgetSlug) {
      const publicId = `wgt_main_${widgetSlug}`;
      const exported = await exportInstanceDataFromBob({
        persistAssets: true,
        exportMode: 'current',
        assetScope: 'curated',
        assetPublicId: publicId,
        assetWidgetType: widgetSlug,
      });
      const config = exported?.instanceData;
      if (!config || typeof config !== 'object') {
        throw new Error('[DevStudio] Bob export did not include instanceData');
      }

      const exportedPublicId = exported?.meta?.publicId;
      if (exportedPublicId && exportedPublicId !== publicId) {
        const ok = window.confirm(
          `Save the currently loaded editor state (${exportedPublicId}) into default instance (${publicId})?`,
        );
        if (!ok) throw new Error('[DevStudio] Canceled');
      }

      // Source-of-truth for compiled defaults is Tokyo widget spec.json. In local dev, keep it in sync
      // so downstream curated instances deterministically inherit the updated baseline.
      const defaultsForSpec = stripTokyoBaseFromConfig(cloneJson(config), TOKYO_BASE);
      await updateTokyoWidgetSpecDefaults({ widgetSlug, defaults: defaultsForSpec });
      compiledCache.delete(widgetSlug);
      const curatedWorkspaceId = await resolveCuratedWorkspaceId();

      await createWorkspaceInstance({
        workspaceId: curatedWorkspaceId,
        widgetType: widgetSlug,
        publicId,
        config,
        status: 'published',
      });
      await updateWorkspaceInstance({
        workspaceId: curatedWorkspaceId,
        publicId,
        config,
        status: 'published',
      });
      return { publicId, config };
    }

    async function updateTokyoWidgetSpecDefaults({ widgetSlug, defaults }) {
      const res = await fetch(`/api/widget-spec-defaults?_t=${Date.now()}`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ widgetType: widgetSlug, defaults }),
      });
      const text = await res.text().catch(() => '');
      if (!res.ok) {
        throw new Error(
          `[DevStudio] Update widget spec defaults failed (HTTP ${res.status})${text ? `: ${text}` : ''}`,
        );
      }
      return text ? JSON.parse(text) : null;
    }

    function readConfigValueAtPath(config, path) {
      if (!config || typeof config !== 'object' || Array.isArray(config)) return undefined;
      const segments = String(path || '')
        .split('.')
        .filter(Boolean);
      if (!segments.length) return undefined;
      let current = config;
      for (const segment of segments) {
        if (!current || typeof current !== 'object' || Array.isArray(current)) return undefined;
        if (!Object.prototype.hasOwnProperty.call(current, segment)) return undefined;
        current = current[segment];
      }
      return current;
    }

    function buildThemeValuesFromConfig(config, compiled) {
      const values = {};
      const controls = Array.isArray(compiled?.controls) ? compiled.controls : [];
      const allowedPrefixes = ['stage.', 'pod.', 'appearance.', 'typography.'];
      const tokenPathPattern = /(^|\.)__[^.]+__(\.|$)/;

      controls.forEach((control) => {
        if (!control || typeof control !== 'object') return;
        const path = typeof control.path === 'string' ? control.path.trim() : '';
        if (!path) return;
        if (path === 'appearance.theme') return;
        if (!allowedPrefixes.some((prefix) => path.startsWith(prefix))) return;
        if (tokenPathPattern.test(path)) return;
        if (Object.prototype.hasOwnProperty.call(values, path)) return;
        const value = readConfigValueAtPath(config, path);
        if (value === undefined) return;
        values[path] = cloneJson(value);
      });

      return values;
    }

    function normalizeColorFillValue(raw) {
      if (raw && typeof raw === 'object' && !Array.isArray(raw)) {
        return cloneJson(raw);
      }
      if (typeof raw !== 'string') return raw;
      const color = raw.trim();
      if (!color) return raw;
      if (color.startsWith('{')) {
        try {
          const parsed = JSON.parse(color);
          if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
            return cloneJson(parsed);
          }
        } catch {}
      }
      return { type: 'color', color };
    }

    function normalizeThemeValuesForCompiledControls(values, compiled) {
      const normalized = cloneJson(values);
      const controls = Array.isArray(compiled?.controls) ? compiled.controls : [];
      controls.forEach((control) => {
        if (!control || typeof control !== 'object') return;
        if (control.type !== 'dropdown-fill') return;
        const path = typeof control.path === 'string' ? control.path : '';
        if (!path || !Object.prototype.hasOwnProperty.call(normalized, path)) return;
        normalized[path] = normalizeColorFillValue(normalized[path]);
      });
      return normalized;
    }

    async function listTokyoThemes() {
      const res = await fetch(`/api/themes/list?_t=${Date.now()}`, { cache: 'no-store' });
      const text = await res.text().catch(() => '');
      if (!res.ok) {
        throw new Error(
          `[DevStudio] List themes failed (HTTP ${res.status})${text ? `: ${text}` : ''}`,
        );
      }
      const json = text ? JSON.parse(text) : null;
      const themes = Array.isArray(json?.themes) ? json.themes : [];
      return themes
        .map((theme) => ({
          id: String(theme?.id || '')
            .trim()
            .toLowerCase(),
          label: String(theme?.label || '').trim(),
        }))
        .filter((theme) => Boolean(theme.id) && theme.id !== 'custom');
    }

    function openThemeModal({ themes, defaultThemeId }) {
      if (!themeModal || !(themeModalSelect instanceof HTMLSelectElement)) {
        return Promise.resolve(null);
      }

      const normalizedThemes = Array.isArray(themes) ? themes : [];
      if (!normalizedThemes.length) return Promise.resolve(null);

      themeModalSelect.replaceChildren();
      const hasDefaultTheme =
        Boolean(defaultThemeId) && normalizedThemes.some((theme) => theme.id === defaultThemeId);
      if (!hasDefaultTheme) {
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'Select theme to overwrite...';
        placeholder.disabled = true;
        placeholder.selected = true;
        placeholder.hidden = true;
        themeModalSelect.appendChild(placeholder);
      }
      normalizedThemes.forEach((theme) => {
        const opt = document.createElement('option');
        opt.value = theme.id;
        opt.textContent = theme.label ? `${theme.label} (${theme.id})` : theme.id;
        themeModalSelect.appendChild(opt);
      });

      const initial = hasDefaultTheme ? defaultThemeId : '';
      themeModalSelect.value = initial;

      themeModal.hidden = false;
      themeModalSelect.focus();

      return new Promise((resolve) => {
        themeModalState = { resolve };
      });
    }

    function closeThemeModal(result) {
      if (themeModal) themeModal.hidden = true;
      if (themeModalState && typeof themeModalState.resolve === 'function') {
        themeModalState.resolve(result ?? null);
      }
      themeModalState = null;
    }

    async function updateTokyoTheme({ themeId, values }) {
      const res = await fetch(`/api/themes/update?_t=${Date.now()}`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ themeId, values }),
      });
      const text = await res.text().catch(() => '');
      if (!res.ok) {
        throw new Error(
          `[DevStudio] Update theme failed (HTTP ${res.status})${text ? `: ${text}` : ''}`,
        );
      }
      return text ? JSON.parse(text) : null;
    }

    async function updateThemeFromEditor() {
      if (!currentPublicId) {
        throw new Error('[DevStudio] Select an instance first.');
      }
      const current = instances.find((inst) => inst.publicId === currentPublicId);
      const widgetSlug = current?.widgetSlug || normalizeWidgetname(current?.widgetname);
      if (!widgetSlug) {
        throw new Error('[DevStudio] Unable to resolve widget type from the selected instance.');
      }

      const localHostRegex = /^https?:\/\/(?:localhost|127\.0\.0\.1)(?::\d+)?$/i;
      if (!localHostRegex.test(BOB_ORIGIN)) {
        throw new Error(
          '[DevStudio] Update Theme requires local Bob (http://localhost:3000). Remote Bob does not reflect local Tokyo theme edits.',
        );
      }

      const themeAssetPublicId =
        isCuratedPublicId(currentPublicId) || currentPublicId.startsWith('wgt_main_')
          ? currentPublicId
          : `wgt_main_${widgetSlug}`;

      const exported = await exportInstanceDataFromBob({
        persistAssets: true,
        exportMode: 'current',
        assetScope: 'curated',
        assetPublicId: themeAssetPublicId,
        assetWidgetType: widgetSlug,
      });
      const config = exported?.instanceData;
      if (!config || typeof config !== 'object') {
        throw new Error('[DevStudio] Bob export did not include instanceData');
      }

      const editorThemeId = String(config?.appearance?.theme || '')
        .trim()
        .toLowerCase();
      const themes = await listTokyoThemes();
      const lastThemeId = String(sessionStorage.getItem(THEME_UPDATE_LAST_ID_STORAGE) || '')
        .trim()
        .toLowerCase();
      const hasEditorTheme =
        Boolean(editorThemeId) &&
        editorThemeId !== 'custom' &&
        themes.some((theme) => theme.id === editorThemeId);
      const hasLastTheme =
        Boolean(lastThemeId) &&
        lastThemeId !== 'custom' &&
        themes.some((theme) => theme.id === lastThemeId);
      const defaultThemeId =
        hasEditorTheme ? editorThemeId : hasLastTheme ? lastThemeId : '';
      if (!themes?.length) throw new Error('[DevStudio] Theme list not found.');
      const themeId = await openThemeModal({ themes, defaultThemeId });
      if (!themeId) throw new Error('[DevStudio] Canceled');
      const compiled = await ensureCompiledWidget(widgetSlug);
      const values = buildThemeValuesFromConfig(config, compiled);
      if (!Object.keys(values).length) {
        throw new Error('[DevStudio] Theme values not found in current config.');
      }

      const normalizedValues = normalizeThemeValuesForCompiledControls(values, compiled);
      const cleanedValues = stripTokyoBaseFromConfig(cloneJson(normalizedValues), TOKYO_BASE);
      await updateTokyoTheme({ themeId, values: cleanedValues });
      sessionStorage.setItem(THEME_UPDATE_LAST_ID_STORAGE, themeId);
      compiledCache.delete(widgetSlug);
      if (currentPublicId) {
        await sendInstanceToIframe(currentPublicId);
      }
      alert(`[DevStudio] Theme "${themeId}" updated from current editor state.`);
      return { themeId, values: cleanedValues };
    }

    async function resetMainInstanceFromJson(widgetSlug) {
      compiledCache.delete(widgetSlug);
      const compiled = await ensureCompiledWidget(widgetSlug);
      const defaults =
        compiled?.defaults && typeof compiled.defaults === 'object' ? compiled.defaults : null;
      if (!defaults) throw new Error('[DevStudio] Compiled widget did not include defaults');

      const publicId = `wgt_main_${widgetSlug}`;
      const ok = window.confirm(
        `Reset ${publicId} from JSON defaults? This will overwrite the current config.`,
      );
      if (!ok) throw new Error('[DevStudio] Canceled');

      const config = cloneJson(defaults);
      const curatedWorkspaceId = await resolveCuratedWorkspaceId();
      await createWorkspaceInstance({
        workspaceId: curatedWorkspaceId,
        widgetType: widgetSlug,
        publicId,
        config,
        status: 'published',
      });
      await updateWorkspaceInstance({
        workspaceId: curatedWorkspaceId,
        publicId,
        config,
        status: 'published',
      });
      return { publicId, config };
    }

    async function updateCuratedInstanceFromEditor(instance) {
      if (!instance || !isCuratedPublicId(instance.publicId)) {
        throw new Error('[DevStudio] Select a curated instance first.');
      }
      const widgetSlug = instance.widgetSlug || requireWidgetSlugForAction();
      const publicId = instance.publicId;
      const exported = await exportInstanceDataFromBob({
        persistAssets: true,
        exportMode: 'current',
        assetScope: 'curated',
        assetPublicId: publicId,
        assetWidgetType: widgetSlug,
      });
      const config = exported?.instanceData;
      if (!config || typeof config !== 'object') {
        throw new Error('[DevStudio] Bob export did not include instanceData');
      }

      const exportedPublicId = exported?.meta?.publicId;
      if (exportedPublicId && exportedPublicId !== publicId) {
        const ok = window.confirm(
          `Update curated instance (${publicId}) with the currently loaded editor state (${exportedPublicId})?`,
        );
        if (!ok) throw new Error('[DevStudio] Canceled');
      }

      const ok = window.confirm(
        `Update curated instance ${publicId} in place? This will overwrite the current config.`,
      );
      if (!ok) throw new Error('[DevStudio] Canceled');
      const curatedWorkspaceId = await resolveCuratedWorkspaceId();

      await updateWorkspaceInstance({
        workspaceId: curatedWorkspaceId,
        publicId,
        config,
        status: 'published',
        meta: instance.meta ?? undefined,
      });

      return { publicId, config };
    }

    function readCuratedCreateDraft() {
      const widgetSlug = curatedModalState?.widgetSlug || null;
      const styleBaseRaw =
        curatedStyleNameField instanceof HTMLInputElement ? curatedStyleNameField.value : '';
      const variantPrimaryRaw =
        curatedVariantPrimaryField instanceof HTMLInputElement
          ? curatedVariantPrimaryField.value
          : '';
      const variantSecondaryRaw =
        curatedVariantSecondaryField instanceof HTMLInputElement
          ? curatedVariantSecondaryField.value
          : '';

      const styleBase = normalizeCuratedNameSegment(styleBaseRaw, widgetSlug);
      const variantPrimary = normalizeCuratedNameSegment(variantPrimaryRaw, widgetSlug);
      const variantSecondary = normalizeCuratedNameSegment(variantSecondaryRaw, widgetSlug);
      const rawSegments = [styleBase, variantPrimary, variantSecondary].filter(Boolean);
      const slugSegments = rawSegments.map((segment) => slugifyKey(segment)).filter(Boolean);
      return {
        styleBase,
        variantPrimary,
        variantSecondary,
        styleName: rawSegments.join('.'),
        styleSlug: slugSegments.join('_'),
      };
    }

    function updateCuratedModalPreview() {
      if (!(curatedStylePreview instanceof HTMLElement)) return;
      if (!curatedModalState) {
        curatedStylePreview.textContent = '';
        return;
      }
      const draft = readCuratedCreateDraft();
      if (!draft.styleBase) {
        curatedStylePreview.textContent = 'Instance key preview: add an instance name.';
        return;
      }
      if (!draft.styleSlug) {
        curatedStylePreview.textContent = 'Instance key preview: use at least one letter or number.';
        return;
      }
      curatedStylePreview.textContent = `Public ID: ${buildCuratedPublicId(
        curatedModalState.widgetSlug,
        draft.styleSlug,
      )}`;
    }

    function updateCuratedModalConfirmState() {
      if (!(curatedModalConfirm instanceof HTMLButtonElement)) return;
      if (!curatedModalState) {
        curatedModalConfirm.disabled = true;
        updateCuratedModalPreview();
        return;
      }
      const draft = readCuratedCreateDraft();
      curatedModalConfirm.disabled = !draft.styleBase || !draft.styleSlug;
      updateCuratedModalPreview();
    }

    function openCuratedModal({ widgetSlug }) {
      if (
        !curatedModal ||
        !curatedModalConfirm ||
        !(curatedStyleNameField instanceof HTMLInputElement)
      )
        return;
      curatedModalState = {
        widgetSlug,
      };

      if (curatedModalTitle instanceof HTMLElement) {
        curatedModalTitle.textContent = 'Create curated instance';
      }
      if (curatedModalSubtitle instanceof HTMLElement) {
        curatedModalSubtitle.textContent = `Creates wgt_curated_${widgetSlug}_<name>.`;
      }

      curatedStyleNameField.readOnly = false;
      curatedStyleNameField.value = '';
      if (curatedVariantPrimaryField instanceof HTMLInputElement) {
        curatedVariantPrimaryField.readOnly = false;
        curatedVariantPrimaryField.value = '';
      }
      if (curatedVariantSecondaryField instanceof HTMLInputElement) {
        curatedVariantSecondaryField.readOnly = false;
        curatedVariantSecondaryField.value = '';
      }

      const icon = curatedModalConfirm.querySelector('.diet-btn-ictxt__icon');
      if (icon) icon.setAttribute('data-icon', 'plus.square');
      const label = curatedModalConfirm.querySelector('.diet-btn-ictxt__label');
      if (label) label.textContent = 'Create curated instance';
      curatedModalConfirm.dataset.tone = 'green4';

      updateCuratedModalConfirmState();
      curatedModal.hidden = false;
      curatedStyleNameField.focus();
    }

    function closeCuratedModal() {
      if (curatedModal) curatedModal.hidden = true;
      curatedModalState = null;
      if (curatedStyleNameField instanceof HTMLInputElement) curatedStyleNameField.value = '';
      if (curatedVariantPrimaryField instanceof HTMLInputElement) curatedVariantPrimaryField.value = '';
      if (curatedVariantSecondaryField instanceof HTMLInputElement) curatedVariantSecondaryField.value = '';
      if (curatedStylePreview instanceof HTMLElement) curatedStylePreview.textContent = '';
      updateCuratedModalConfirmState();
    }

    async function submitCuratedModal() {
      if (!curatedModalState) return;
      if (!currentPublicId) throw new Error('[DevStudio] Select an instance first.');
      const draft = readCuratedCreateDraft();
      const styleName = draft.styleName;
      const styleSlug = draft.styleSlug;
      const styleVariants = {
        primary: draft.variantPrimary || null,
        secondary: draft.variantSecondary || null,
      };
      if (!draft.styleBase || !styleSlug) throw new Error('[DevStudio] Enter an instance name.');

      const publicId = buildCuratedPublicId(curatedModalState.widgetSlug, styleSlug);
      const existing = instances.find((inst) => String(inst.publicId || '').toLowerCase() === publicId.toLowerCase());
      if (existing) {
        throw new Error('[DevStudio] Instance key already exists. Choose a different name.');
      }
      const exported = await exportInstanceDataFromBob({
        persistAssets: true,
        exportMode: 'current',
        assetScope: 'curated',
        assetPublicId: publicId,
        assetWidgetType: curatedModalState.widgetSlug,
      });
      const sourceConfig = exported?.instanceData;
      if (!sourceConfig || typeof sourceConfig !== 'object') {
        throw new Error('[DevStudio] Bob export did not include instanceData');
      }
      const meta = {
        styleName,
        styleSlug,
      };
      if (styleVariants.primary || styleVariants.secondary) {
        meta.variants = styleVariants;
      }
      const curatedWorkspaceId = await resolveCuratedWorkspaceId();

      await createWorkspaceInstance({
        workspaceId: curatedWorkspaceId,
        widgetType: curatedModalState.widgetSlug,
        publicId,
        config: sourceConfig,
        status: 'published',
        meta,
      });

      closeCuratedModal();
      await refreshInstancesAndSelect(publicId);
    }

    async function refreshInstancesAndSelect(publicId) {
      await fetchInstances();
      if (!publicId) return;
      const found = instances.find((inst) => inst.publicId === publicId);
      if (found) {
        switchInstance(publicId);
      }
    }

    if (isLocalDevStudio && privilegedActions) {
      privilegedActions.style.display = 'inline-flex';
    }

    privilegedUpdateDefaults?.addEventListener('click', async () => {
      try {
        const widgetSlug = requireWidgetSlugForAction();
        const result = await updateDefaultsMainInstanceFromEditor(widgetSlug);
        await refreshInstancesAndSelect(result.publicId);
      } catch (err) {
        alert(err instanceof Error ? err.message : String(err));
      }
    });

    privilegedUpdateTheme?.addEventListener('click', async () => {
      try {
        await updateThemeFromEditor();
      } catch (err) {
        alert(err instanceof Error ? err.message : String(err));
      }
    });

    privilegedResetFromJson?.addEventListener('click', async () => {
      try {
        const widgetSlug = requireWidgetSlugForAction();
        const result = await resetMainInstanceFromJson(widgetSlug);
        await refreshInstancesAndSelect(result.publicId);
      } catch (err) {
        alert(err instanceof Error ? err.message : String(err));
      }
    });

    createCuratedInstanceBtn?.addEventListener('click', () => {
      try {
        if (!currentPublicId) throw new Error('[DevStudio] Select an instance first.');
        const instance = instances.find((inst) => inst.publicId === currentPublicId);
        const widgetSlug = instance?.widgetSlug || requireWidgetSlugForAction();
        openCuratedModal({ widgetSlug });
      } catch (err) {
        alert(err instanceof Error ? err.message : String(err));
      }
    });

    updateCuratedInstanceBtn?.addEventListener('click', async () => {
      try {
        if (!currentPublicId) throw new Error('[DevStudio] Select an instance first.');
        const instance = instances.find((inst) => inst.publicId === currentPublicId);
        const result = await updateCuratedInstanceFromEditor(instance);
        await refreshInstancesAndSelect(result.publicId);
      } catch (err) {
        alert(err instanceof Error ? err.message : String(err));
      }
    });

    refreshPraguePreviewBtn?.addEventListener('click', async () => {
      const labelEl = refreshPraguePreviewBtn?.querySelector('.diet-btn-ictxt__label');
      const previousLabel = labelEl?.textContent || 'Refresh Prague';
      try {
        if (!currentPublicId) throw new Error('[DevStudio] Select an instance first.');
        if (!isCuratedPublicId(currentPublicId) && !currentPublicId.startsWith('wgt_main_')) {
          throw new Error('[DevStudio] Select a curated instance first.');
        }
        if (refreshPraguePreviewBtn) refreshPraguePreviewBtn.disabled = true;
        if (labelEl) labelEl.textContent = 'Queuing...';
        const curatedWorkspaceId = await resolveCuratedWorkspaceId();
        const res = await privilegedActionsFetch(
          `${PARIS_API}/workspaces/${encodeURIComponent(curatedWorkspaceId)}/instances/${encodeURIComponent(
            currentPublicId,
          )}/render-snapshot?subject=workspace&_t=${Date.now()}`,
          {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
          },
        );
        const text = await res.text().catch(() => '');
        if (!res.ok)
          throw new Error(
            `[DevStudio] Refresh Prague failed (HTTP ${res.status})${text ? `: ${text}` : ''}`,
          );
        alert(
          `[DevStudio] Queued snapshot refresh for ${currentPublicId}. Prague should reflect within ~60s. (If your latest edits aren’t showing, click “Update Curated” first.)`,
        );
        if (labelEl) labelEl.textContent = 'Queued';
        setTimeout(() => {
          if (labelEl) labelEl.textContent = previousLabel;
        }, 1500);
      } catch (err) {
        alert(err instanceof Error ? err.message : String(err));
        if (labelEl) labelEl.textContent = previousLabel;
      } finally {
        if (refreshPraguePreviewBtn) refreshPraguePreviewBtn.disabled = false;
      }
    });

    translateSelectedLocalesBtn?.addEventListener('click', async () => {
      try {
        if (!currentPublicId) throw new Error('[DevStudio] Select an instance first.');
        if (!isCuratedPublicId(currentPublicId) && !currentPublicId.startsWith('wgt_main_')) {
          throw new Error('[DevStudio] Select a curated instance first.');
        }
        const curatedWorkspaceId = await resolveCuratedWorkspaceId();

        const res = await privilegedActionsFetch(
          `${PARIS_API}/workspaces/${encodeURIComponent(curatedWorkspaceId)}/instances/${encodeURIComponent(
            currentPublicId,
          )}/l10n/enqueue-selected?subject=workspace&_t=${Date.now()}`,
          {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: '{}',
          },
        );
        const payloadText = await res.text().catch(() => '');
        if (!res.ok)
          throw new Error(
            `[DevStudio] Translate failed (HTTP ${res.status})${payloadText ? `: ${payloadText}` : ''}`,
          );
        let payload = null;
        try {
          payload = payloadText ? JSON.parse(payloadText) : null;
        } catch {}
        const queued = payload?.queued ?? null;
        const skipped = payload?.skipped ?? null;
        if (typeof queued === 'number' && queued === 0) {
          const applyStep = isCuratedPublicId(currentPublicId)
            ? 'Update Curated'
            : 'Update Config';
          alert(
            `[DevStudio] No locale jobs were queued for ${currentPublicId}. If you edited base content in Bob, click "${applyStep}" first, then click "Translate".${typeof skipped === 'number' ? ` (skipped: ${skipped})` : ''}`,
          );
        } else {
          alert(
            `[DevStudio] Queued ${typeof queued === 'number' ? queued : 'translation'} job(s) for ${currentPublicId}${typeof skipped === 'number' ? ` (skipped: ${skipped})` : ''}.`,
          );
        }
        refreshL10nStatus(currentPublicId).catch(() => {});
      } catch (err) {
        alert(err instanceof Error ? err.message : String(err));
      }
    });

    curatedModalConfirm?.addEventListener('click', async () => {
      try {
        await submitCuratedModal();
      } catch (err) {
        alert(err instanceof Error ? err.message : String(err));
      }
    });

    curatedModalClose?.addEventListener('click', () => {
      closeCuratedModal();
    });

    curatedModalCancel?.addEventListener('click', () => {
      closeCuratedModal();
    });

    themeModalConfirm?.addEventListener('click', () => {
      try {
        if (!(themeModalSelect instanceof HTMLSelectElement))
          throw new Error('[DevStudio] Theme selector missing');
        const themeId = String(themeModalSelect.value || '')
          .trim()
          .toLowerCase();
        if (!themeId) throw new Error('[DevStudio] Select a theme first.');
        closeThemeModal(themeId);
      } catch (err) {
        alert(err instanceof Error ? err.message : String(err));
      }
    });

    themeModalClose?.addEventListener('click', () => {
      closeThemeModal(null);
    });

    themeModalCancel?.addEventListener('click', () => {
      closeThemeModal(null);
    });

    themeModal?.addEventListener('click', (event) => {
      if (event.target === themeModal) closeThemeModal(null);
    });

    document.addEventListener(
      'keydown',
      (event) => {
        if (event.key !== 'Escape') return;
        if (themeModal && !themeModal.hidden) closeThemeModal(null);
      },
      { signal: abortController.signal },
    );

    if (curatedStyleNameField instanceof HTMLInputElement) {
      curatedStyleNameField.addEventListener('input', updateCuratedModalConfirmState);
    }
    if (curatedVariantPrimaryField instanceof HTMLInputElement) {
      curatedVariantPrimaryField.addEventListener('input', updateCuratedModalConfirmState);
    }
    if (curatedVariantSecondaryField instanceof HTMLInputElement) {
      curatedVariantSecondaryField.addEventListener('input', updateCuratedModalConfirmState);
    }

    async function sendInstanceToIframe(publicId) {
      if (!publicId) {
        throw new Error('[DevStudio] Missing publicId for sendInstanceToIframe');
      }
      const requestSeq = ++sendInstanceSeq;
      const totalStart = performance.now();

      const target = iframe.contentWindow;
      if (!target) {
        throw new Error('[DevStudio] Bob iframe contentWindow unavailable');
      }

      const instance = instances.find((inst) => inst.publicId === publicId);
      if (!instance) {
        throw new Error(`[DevStudio] Instance not found for publicId ${publicId}`);
      }
      const payloadStart = performance.now();
      const payloadResult = await fetchInstancePayload(publicId).then((value) => ({
        value,
        durationMs: performance.now() - payloadStart,
      }));
      if (requestSeq !== sendInstanceSeq) return;
      const payload = payloadResult.value;
      const payloadWidgetType =
        typeof payload.widgetType === 'string' && payload.widgetType.trim()
          ? normalizeWidgetname(payload.widgetType)
          : '';
      const slug = payloadWidgetType;
      if (!slug) {
        throw new Error(`[DevStudio] Missing widgetType in instance payload for ${publicId}`);
      }
      const label =
        typeof payload.displayName === 'string' && payload.displayName.trim()
          ? payload.displayName.trim()
          : typeof instance.label === 'string' && instance.label.trim()
            ? instance.label.trim()
            : DEFAULT_INSTANCE_DISPLAY_NAME;

      let compiled = compiledCache.get(slug);
      const compiledStart = performance.now();
      const compiledPromise = compiled
        ? Promise.resolve({ value: compiled, durationMs: performance.now() - compiledStart })
        : ensureCompiledWidget(slug).then((nextCompiled) => ({
            value: nextCompiled,
            durationMs: performance.now() - compiledStart,
          }));

      const compiledResult = await compiledPromise;
      if (requestSeq !== sendInstanceSeq) return;
      compiled = compiledResult.value;
      const config =
        payload.config && typeof payload.config === 'object' && !Array.isArray(payload.config)
          ? payload.config
          : null;
      if (!config) {
        throw new Error(`[DevStudio] Invalid instance config payload for ${publicId}`);
      }
      const workspaceId =
        payload.workspace && typeof payload.workspace === 'object' && typeof payload.workspace.id === 'string'
          ? payload.workspace.id.trim()
          : '';
      if (!workspaceId) {
        throw new Error(`[DevStudio] Missing workspace context in instance payload for ${publicId}`);
      }
      const ownerAccountId =
        typeof payload.ownerAccountId === 'string' && payload.ownerAccountId.trim()
          ? payload.ownerAccountId.trim()
          : payload.workspace &&
              typeof payload.workspace === 'object' &&
              typeof payload.workspace.accountId === 'string' &&
              payload.workspace.accountId.trim()
            ? payload.workspace.accountId.trim()
            : '';
      if (!ownerAccountId) {
        throw new Error(`[DevStudio] Missing ownerAccountId in instance payload for ${publicId}`);
      }
      instance.config = config;
      instance.localization = payload.localization ?? null;
      instance.policy = payload.policy ?? null;
      instance.enforcement = payload.enforcement ?? null;
      instance.ownerAccountId = ownerAccountId;
      console.log('[DevStudio] Posting instance to Bob', { publicId, widgetname: slug });
      await postOpenEditorAndWait(target, {
        type: OPEN_EDITOR_EVENTS.openEditor,
        subjectMode: 'workspace',
        publicId,
        workspaceId,
        ownerAccountId: instance.ownerAccountId,
        label,
        widgetname: slug,
        compiled,
        instanceData: config,
        localization: instance.localization,
        policy: instance.policy ?? undefined,
        enforcement: instance.enforcement ?? undefined,
      });
      console.log('[DevStudio] Instance load timings', {
        publicId,
        compileMs: Math.round(compiledResult.durationMs),
        payloadMs: Math.round(payloadResult.durationMs),
        totalMs: Math.round(performance.now() - totalStart),
      });
    }

    async function postOpenEditorAndWait(target, messageBase) {
      const sessionId = String(bobSessionId || '').trim();
      if (!sessionId) {
        throw new Error('[DevStudio] Bob session is not ready');
      }
      const requestId = crypto.randomUUID();
      const message = { ...messageBase, requestId, sessionId };

      await new Promise((resolve, reject) => {
        let settled = false;
        let acknowledged = false;
        let attempts = 0;
        let retryTimer = null;
        let timeoutTimer = null;

        const cleanup = () => {
          if (retryTimer) clearTimeout(retryTimer);
          if (timeoutTimer) clearTimeout(timeoutTimer);
          window.removeEventListener('message', onMessage);
        };

        const fail = (error) => {
          if (settled) return;
          settled = true;
          cleanup();
          reject(error);
        };

        const succeed = () => {
          if (settled) return;
          settled = true;
          cleanup();
          resolve();
        };

        const send = () => {
          if (settled) return;
          attempts += 1;
          target.postMessage(message, BOB_ORIGIN);

          if (!acknowledged) {
            if (attempts >= OPEN_EDITOR_TIMING.maxAckAttempts) {
              fail(new Error('[DevStudio] Timed out waiting for bob:open-editor-ack'));
              return;
            }
            retryTimer = setTimeout(send, OPEN_EDITOR_TIMING.ackRetryMs);
          }
        };

        const onMessage = (event) => {
          if (event.origin !== BOB_ORIGIN) return;
          if (event.source !== iframe.contentWindow) return;
          const data = event.data;
          if (!data || typeof data !== 'object') return;
          if (String(data.requestId || '') !== requestId) return;
          if (String(data.sessionId || '') !== sessionId) return;

          if (data.type === OPEN_EDITOR_EVENTS.ack) {
            acknowledged = true;
            if (retryTimer) {
              clearTimeout(retryTimer);
              retryTimer = null;
            }
            return;
          }

          if (data.type === OPEN_EDITOR_EVENTS.applied) {
            succeed();
            return;
          }

          if (data.type === OPEN_EDITOR_EVENTS.failed) {
            const reason = String(data.reasonKey || data.message || '[DevStudio] Bob failed to apply instance');
            fail(new Error(reason));
          }
        };

        timeoutTimer = setTimeout(
          () => fail(new Error('[DevStudio] Timed out waiting for bob:open-editor-applied')),
          OPEN_EDITOR_TIMING.timeoutMs,
        );
        window.addEventListener('message', onMessage);
        send();
      });
    }

    function setOpen(nextState) {
      isOpen = nextState;
      dropdown.setAttribute('data-state', isOpen ? 'open' : 'closed');
      control.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    }

    if (widgetSelect instanceof HTMLSelectElement) {
      widgetSelect.addEventListener(
        'change',
        () => {
          const nextWidgetSlug = normalizeWidgetname(widgetSelect.value);
          if (!nextWidgetSlug) return;
          if (nextWidgetSlug === selectedWidgetSlug) return;
          selectedWidgetSlug = nextWidgetSlug;

          const scopedInstances = getScopedInstances();
          const nextPublicId = scopedInstances.some((inst) => inst.publicId === currentPublicId)
            ? currentPublicId
            : scopedInstances[0]?.publicId || null;
          const instanceChanged = nextPublicId !== currentPublicId;
          currentPublicId = nextPublicId;

          setOpen(false);
          updateCurrentLabel();
          renderInstances();

          if (currentPublicId && instanceChanged) {
            sendInstanceToIframe(currentPublicId).catch((error) => {
              console.error('[DevStudio] Failed to send instance to Bob', error);
            });
          }
          refreshL10nStatus(currentPublicId).catch(() => {});
        },
        { signal: abortController.signal },
      );
    }

    control.addEventListener(
      'click',
      () => {
        setOpen(!isOpen);
      },
      { signal: abortController.signal },
    );

    control.addEventListener(
      'keydown',
      (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          setOpen(!isOpen);
        } else if (event.key === 'ArrowDown') {
          event.preventDefault();
          setOpen(true);
          const firstOption = menu.querySelector('[data-public-id]');
          firstOption?.focus();
        } else if (event.key === 'Escape') {
          setOpen(false);
        }
      },
      { signal: abortController.signal },
    );

    menu.addEventListener(
      'keydown',
      (event) => {
        if (event.key === 'Escape') {
          setOpen(false);
          control.focus();
        } else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
          const options = Array.from(menu.querySelectorAll('[data-public-id]'));
          const currentIndex = options.indexOf(document.activeElement);
          const nextIndex = event.key === 'ArrowUp' ? currentIndex - 1 : currentIndex + 1;
          const next = options[nextIndex];
          if (next) {
            event.preventDefault();
            next.focus();
          }
        } else if (event.key === 'Home') {
          const first = menu.querySelector('[data-public-id]');
          if (first) {
            event.preventDefault();
            first.focus();
          }
        } else if (event.key === 'End') {
          const options = menu.querySelectorAll('[data-public-id]');
          const last = options[options.length - 1];
          if (last) {
            event.preventDefault();
            last.focus();
          }
        } else if (event.key === 'Tab') {
          setOpen(false);
        } else if (event.key === 'Enter' || event.key === ' ') {
          const target = event.target.closest('[data-public-id]');
          if (target) {
            event.preventDefault();
            target.click();
          }
        }
      },
      { signal: abortController.signal },
    );

    document.addEventListener(
      'click',
      (event) => {
        if (!dropdown.contains(event.target)) {
          setOpen(false);
        }
      },
      { signal: abortController.signal },
    );

    (async () => {
      try {
        await loadOpenEditorLifecycleContract();
        initBobIframe();
        await fetchInstances();
      } catch (error) {
        console.error('[DevStudio] Failed to fetch instances', error);
        currentLabel.textContent = 'Error loading instances';
      }
    })();
  </script>
</div>
